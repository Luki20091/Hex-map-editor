<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Zablokowanie przybliżania/oddalania strony przez przeglądarkę -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Hex Map Editor - BETA 1.6</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/js/all.min.js" crossorigin="anonymous" type="text/javascript"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      display: flex;
      overflow: hidden;
      -webkit-user-select: none;
      -moz-user-select: none;
    }
    canvas {
      display: block;
      background-color: #111111;
      cursor: url('assets/cursors/pencil.svg') 0 32, auto;
    }
    #controls {
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 8px;
      width: 240px;
      overflow-y: auto;
      max-height: 100vh;
      box-shadow: -2px 0 5px rgba(0, 0, 0, 0.2);
      position: fixed;
    }
    .tile {
      display: flex;
      align-items: center;
      margin: 5px 0;
      cursor: pointer;
      padding: 5px;
      border-radius: 4px;
      transition: ease-in-out background 0.2s;
    }
    .tile:hover {
      background: rgba(0, 0, 0, 0.1);
    }
    .tile.selected {
      background: rgba(0, 123, 255, 0.2);
    }
    .tile-color {
      height: 24px;
      margin-right: 10px;
      aspect-ratio: 1;
      clip-path: polygon(-50% 50%,50% 100%,150% 50%,50% 0);
    }
    .tile-flag img {
      height: 24px;
      margin-right: 10px;
    }
    button {
      display: block;
      margin: 10px 0;
      padding: 5px 10px;
      border: none;
      background: #007BFF;
      color: #fff;
      cursor: pointer;
      border-radius: 4px;
    }
    button:hover {
      background: #0056b3;
    }
    .tool-button {
      margin: 5px 0;
      padding: 10px;
      border: none;
      background: #007BFF;
      color: #fff;
      cursor: pointer;
      border-radius: 4px;
      display: block;
      font-size: 20px;
      text-align: center;
    }
    .tool-button.selected {
      background: #0056b3;
    }
    .input-group {
      margin: 10px 0;
    }
    input[type="number"],
    input[type="range"] {
      width: 100%;
      padding: 5px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
  </style>
</head>
<body>
  <canvas id="hexCanvas"></canvas>
  <div id="controls">
    <button id="switchModeButton">Mode: Colors</button>
    <div id="terrainList"></div>
    <div id="objectList" style="display:none;"></div>
    <button class="tool-button selected" data-tool="move"><i class="fas fa-arrows-alt"></i></button>
    <button class="tool-button" data-tool="pencil"><i class="fas fa-pencil"></i></button>
    <button class="tool-button" data-tool="big-pencil"><i class="fa-solid fa-paintbrush"></i></button>
    <button class="tool-button" data-tool="bucket"><i class="fa-solid fa-fill-drip fa-flip-horizontal"></i></button>
    <button class="tool-button" data-tool="eraser"><i class="fa-solid fa-eraser"></i></button>
    <button id="resetButton">Reset Map</button>
    <button id="exportButton">Export to JSON</button>
    <button id="importButton">Import from JSON</button>
    <button id="undoButton">Undo</button>
    <button id="redoButton">Redo</button>
    <input type="file" id="fileInput" style="display:none;">
    <div class="input-group">
      <label for="cols">Columns: </label>
      <input type="number" id="cols" value="29" min="5" max="300" />
    </div>
    <div class="input-group">
      <label for="rows">Rows: </label>
      <input type="number" id="rows" value="17" min="5" max="200" />
    </div>
    <div class="input-group">
      <label for="hexSize">Hex Size (Zoom):</label>
      <input type="range" id="hexSize" min="3" max="50" value="25">
    </div>
    <button id="zoomInButton">Zoom In</button>
    <button id="zoomOutButton">Zoom Out</button>
    <button id="resizeButton">Resize Map</button>
  </div>

  <script>
    // Global deklaracje
    const canvas = document.getElementById('hexCanvas');
    const ctx = canvas.getContext('2d');
    const exportButton = document.getElementById('exportButton');
    const importButton = document.getElementById('importButton');
    const fileInput = document.getElementById('fileInput');
    const terrainList = document.getElementById('terrainList');
    const objectList = document.getElementById('objectList');
    const undoButton = document.getElementById('undoButton');
    const redoButton = document.getElementById('redoButton');
    const resetButton = document.getElementById('resetButton');
    const resizeButton = document.getElementById('resizeButton');
    const colsInput = document.getElementById('cols');
    const rowsInput = document.getElementById('rows');
    const hexSizeInput = document.getElementById('hexSize');
    const zoomInButton = document.getElementById('zoomInButton');
    const zoomOutButton = document.getElementById('zoomOutButton');
    const switchModeButton = document.getElementById('switchModeButton');

    // Definicje komórek i obiektów
    const cellDefinitions = [
      { name: "Default", color: "#BBBBBB" },
      { name: "Desert", color: "#FFD700" },
      { name: "Cactus Desert", color: "#CD853F" },
      { name: "Dunes", color: "#F0E68C" },
      { name: "Mountains", color: "#777777" },
      { name: "Forest", color: "#1a7a1a" },
      { name: "Meadow", color: "#00bb00" },
      { name: "Grassland", color: "#7FFF00" },
      { name: "Jungle", color: "#228B66" },
      { name: "Swamp", color: "#3fabaa" },
      { name: "Highlands", color: "#6B8E23" },
      { name: "Snowfield", color: "#FFFFFF" },
      { name: "Snowy Forest", color: "#87ddEB" },
      { name: "Glacier", color: "#4682B4" },
      { name: "Water", color: "#3fabff" },
      { name: "Ocean", color: "#325ddb" }
    ];
    const objectDefinitions = [
      { name: "Poland" },
      { name: "Germany" }
    ];

    let selectedTerrainId = 1;
    let selectedObjectId = 1;
    let drawMode = "color";
    let selectedTool = "move";
    let history = [];
    let historyIndex = -1;
    let cols = 29;
    let rows = 17;
    const hexMap = []; // Każda komórka: { col, row, id, objectId }
    let hexRadius = parseInt(hexSizeInput.value);
    let hexWidth = Math.sqrt(3) * hexRadius;
    let hexHeight = 2 * hexRadius;
    let gap = Math.max(1, hexRadius * 0.1);
    let hexHorizontalSpacing = hexWidth + gap;
    let hexVerticalSpacing = hexHeight * 0.75 + gap;
    let offsetX = 0;
    let offsetY = 0;
    let zoomLevel = 1;
    const keysPressed = {};
    let lastTime = performance.now();
    let imageCache = {};
    let title = "testowy tytuł";
    let description = "testowy opis";

    // Zmienne dla chunkowania
    const CHUNK_SIZE = 10; // liczba komórek w poziomie/wierszu chunka
    let chunkCache = new Map(); // Map: klucz chunka → { canvas, minX, minY, width, height }
    let mapDirty = true;      // flaga informująca, że mapa (chunkCache) wymaga przeliczenia

    // Ustawienie rozmiaru canvasu i centrowanie mapy
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      recalcCenterOffsets();
      drawMap();
    }
    window.addEventListener('resize', resizeCanvas);

    // Oblicz offsety, aby środek mapy (wszystkich komórek) był na środku canvasu
    function recalcCenterOffsets() {
      const bounds = getMapBounds();
      const mapCenterX = (bounds.minX + bounds.maxX) / 2;
      const mapCenterY = (bounds.minY + bounds.maxY) / 2;
      offsetX = -mapCenterX;
      offsetY = -mapCenterY;
    }
    // Oblicza granice mapy na podstawie hexMap
    function getMapBounds() {
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      hexMap.forEach(cell => {
        const pos = evenr_to_pixel(cell);
        if (pos.x < minX) minX = pos.x;
        if (pos.x > maxX) maxX = pos.x;
        if (pos.y < minY) minY = pos.y;
        if (pos.y > maxY) maxY = pos.y;
      });
      return { minX, maxX, minY, maxY };
    }
    // Konwersja even-r na współrzędne pikseli
    function evenr_to_pixel(cell) {
      const off = cell.row % 2 === 0 ? 0.5 : 0;
      const x = hexRadius * Math.sqrt(3) * (cell.col + off);
      const y = hexRadius * (3/2) * cell.row;
      return { x, y };
    }
    // Rysowanie granic mapy
    function drawBorder() {
      for (let row = -1; row <= rows; row++) {
        for (let col = -1; col <= cols; col++) {
          if (row === -1 || row === rows || col === -1 || col === cols) {
            const pos = evenr_to_pixel({ col, row });
            drawHex(pos.x + canvas.width/2 + offsetX, pos.y + canvas.height/2 + offsetY, '#111111');
          }
        }
      }
    }
    // Rysowanie pojedynczego heksagonu (domyślnie na głównym canvasie)
    function drawHex(x, y, color = '#BBBBBB', context = ctx) {
      context.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 3 * i + Math.PI / 6;
        const xOffset = x + Math.cos(angle) * hexRadius;
        const yOffset = y + Math.sin(angle) * hexRadius;
        context.lineTo(xOffset, yOffset);
      }
      context.closePath();
      context.fillStyle = color;
      context.fill();
      context.strokeStyle = '#333333';
      context.lineWidth = 2;
      context.stroke();
    }

    // Funkcje chunkowania
    function getChunkKey(col, row) {
      return Math.floor(col / CHUNK_SIZE) + '_' + Math.floor(row / CHUNK_SIZE);
    }
    // Dla danego chunka (lista komórek) tworzymy offscreen canvas, na którym rysujemy heksy grupując je wg typu (Path2D)
    function updateChunk(chunkKey, chunkCells) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      chunkCells.forEach(cell => {
        const pos = evenr_to_pixel(cell);
        if (pos.x < minX) minX = pos.x;
        if (pos.x > maxX) maxX = pos.x;
        if (pos.y < minY) minY = pos.y;
        if (pos.y > maxY) maxY = pos.y;
      });
      // Rozszerzamy granice, aby uwzględnić całą figurę heksagonu
      minX -= hexRadius;
      minY -= hexRadius;
      maxX += hexRadius;
      maxY += hexRadius;
      const width = maxX - minX;
      const height = maxY - minY;
      const offscreen = document.createElement('canvas');
      offscreen.width = width;
      offscreen.height = height;
      const offCtx = offscreen.getContext('2d');
      // Grupowanie heksów wg identyfikatora terenu
      const terrainGroups = {};
      chunkCells.forEach(cell => {
        const pos = evenr_to_pixel(cell);
        const relX = pos.x - minX;
        const relY = pos.y - minY;
        const terrainId = cell.id;
        if (!terrainGroups[terrainId]) {
          terrainGroups[terrainId] = new Path2D();
        }
        const hexPath = new Path2D();
        for (let i = 0; i < 6; i++) {
          const angle = Math.PI / 3 * i + Math.PI / 6;
          const xOffset = relX + Math.cos(angle) * hexRadius;
          const yOffset = relY + Math.sin(angle) * hexRadius;
          if (i === 0) hexPath.moveTo(xOffset, yOffset);
          else hexPath.lineTo(xOffset, yOffset);
        }
        hexPath.closePath();
        terrainGroups[terrainId].addPath(hexPath);
      });
      for (const terrainId in terrainGroups) {
        offCtx.fillStyle = cellDefinitions[terrainId].color;
        offCtx.fill(terrainGroups[terrainId]);
        offCtx.strokeStyle = '#333333';
        offCtx.lineWidth = 2;
        offCtx.stroke(terrainGroups[terrainId]);
      }
      // Zapisujemy offscreen canvas wraz z pozycją (minX, minY) w układzie świata
      chunkCache.set(chunkKey, { canvas: offscreen, minX: minX, minY: minY, width: width, height: height });
    }
    // Rysowanie mapy – wykorzystanie cache chunków, frustum culling i offscreen canvas
    function drawMap() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBorder();
      // Jeśli mapa uległa zmianie, przebudowujemy chunkCache
      if (mapDirty) {
        chunkCache.clear();
        const chunks = new Map();
        hexMap.forEach(cell => {
          const key = getChunkKey(cell.col, cell.row);
          if (!chunks.has(key)) {
            chunks.set(key, []);
          }
          chunks.get(key).push(cell);
        });
        chunks.forEach((cells, key) => updateChunk(key, cells));
        mapDirty = false;
      }
      // Rysujemy chunki, o ile są widoczne (frustum culling)
      chunkCache.forEach(chunk => {
        const screenX = chunk.minX + canvas.width/2 + offsetX;
        const screenY = chunk.minY + canvas.height/2 + offsetY;
        if (screenX + chunk.width < 0 || screenX > canvas.width ||
            screenY + chunk.height < 0 || screenY > canvas.height) {
          return;
        }
        ctx.drawImage(chunk.canvas, screenX, screenY);
      });
      // Rysowanie obiektów (np. flag) – rysujemy je na wierzchu
      hexMap.forEach(cell => {
        if (cell.objectId) {
          const obj = objectDefinitions[cell.objectId - 1];
          if (obj) {
            const pos = evenr_to_pixel(cell);
            const screenX = pos.x + canvas.width/2 + offsetX;
            const screenY = pos.y + canvas.height/2 + offsetY;
            const flagPath = './assets/flags/' + obj.name + '.svg';
            const image = getImage(flagPath);
            if (image) {
              ctx.drawImage(image, screenX - hexRadius/2, screenY - hexRadius/2, hexRadius, hexRadius);
            } else {
              loadImage(flagPath, (loadedImage) => {
                ctx.drawImage(loadedImage, screenX - hexRadius/2, screenY - hexRadius/2, hexRadius, hexRadius);
              });
            }
          }
        }
      });
    }

    // Obsługa historii (undo/redo)
    function saveHistory() {
      history.length = historyIndex + 1;
      history.push(JSON.parse(JSON.stringify(hexMap)));
      historyIndex++;
    }
    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        hexMap.length = 0;
        hexMap.push(...JSON.parse(JSON.stringify(history[historyIndex])));
        mapDirty = true;
        drawMap();
      }
    }
    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        hexMap.length = 0;
        hexMap.push(...JSON.parse(JSON.stringify(history[historyIndex])));
        mapDirty = true;
        drawMap();
      }
    }

    // Przesuwanie mapy z ograniczeniami, aby nie zniknęła poza ekranem
    function moveMap(dx, dy) {
      offsetX += dx;
      offsetY += dy;
      const bounds = getMapBounds();
      const minAllowedOffsetX = - (bounds.maxX + canvas.width/2);
      const maxAllowedOffsetX = canvas.width/2 - bounds.minX;
      offsetX = Math.min(Math.max(offsetX, minAllowedOffsetX), maxAllowedOffsetX);
      const minAllowedOffsetY = - (bounds.maxY + canvas.height/2);
      const maxAllowedOffsetY = canvas.height/2 - bounds.minY;
      offsetY = Math.min(Math.max(offsetY, minAllowedOffsetY), maxAllowedOffsetY);
      drawMap();
    }

    // Panning myszką (narzędzie 'move')
    let isMousePanning = false;
    canvas.addEventListener('mousedown', (event) => {
      if (selectedTool === 'move') {
        isMousePanning = true;
        canvas.style.cursor = `url('assets/cursors/${selectedTool}2.svg') 0 32, auto`;
      }
    });
    canvas.addEventListener('mouseup', () => {
      if (selectedTool === 'move') {
        isMousePanning = false;
        canvas.style.cursor = `url('assets/cursors/${selectedTool}.svg') 0 32, auto`;
      }
    });
    canvas.addEventListener('mouseleave', () => {
      if (selectedTool === 'move') {
        isMousePanning = false;
      }
    });
    canvas.addEventListener('mousemove', (event) => {
      if (selectedTool === 'move' && isMousePanning) {
        moveMap(event.movementX, event.movementY);
      }
    });

    // Obsługa malowania (dla narzędzi innych niż move)
    let isPainting = false;
    canvas.addEventListener('mousedown', (event) => {
      if (selectedTool !== 'move') {
        isPainting = true;
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        const cell = getCellAt(mouseX, mouseY);
        if (cell) paintCell(cell);
      }
    });
    canvas.addEventListener('mouseup', () => { isPainting = false; });
    canvas.addEventListener('mouseleave', () => { isPainting = false; });
    canvas.addEventListener('mousemove', (event) => {
      if (isPainting && selectedTool !== 'move') {
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        const cell = getCellAt(mouseX, mouseY);
        if (cell) paintCell(cell);
      }
    });

    resetButton.addEventListener('click', initHexMap);
    undoButton.addEventListener('click', undo);
    redoButton.addEventListener('click', redo);

    // Śledzenie stanu klawiszy dla płynnego ruchu mapy
    document.addEventListener('keydown', (event) => {
      if (['w','ArrowUp','a','ArrowLeft','s','ArrowDown','d','ArrowRight'].includes(event.key)) {
        keysPressed[event.key] = true;
        event.preventDefault();
      }
      if (event.ctrlKey && event.key === 'z') {
        event.preventDefault();
        undo();
      }
      if (event.ctrlKey && event.key === 'y') {
        event.preventDefault();
        redo();
      }
    });
    document.addEventListener('keyup', (event) => {
      if (['w','ArrowUp','a','ArrowLeft','s','ArrowDown','d','ArrowRight'].includes(event.key)) {
        keysPressed[event.key] = false;
        event.preventDefault();
      }
    });

    // Pętla animacji dla płynnego ruchu mapy
    function animate() {
      const now = performance.now();
      const dt = (now - lastTime) / 1000;
      lastTime = now;
      let vx = 0, vy = 0;
      if (keysPressed['w'] || keysPressed['ArrowUp']) vy += 1;
      if (keysPressed['s'] || keysPressed['ArrowDown']) vy -= 1;
      if (keysPressed['a'] || keysPressed['ArrowLeft']) vx += 1;
      if (keysPressed['d'] || keysPressed['ArrowRight']) vx -= 1;
      if (vx !== 0 || vy !== 0) {
        const len = Math.sqrt(vx*vx + vy*vy);
        vx /= len;
        vy /= len;
        const speed = 200;
        moveMap(vx * speed * dt, vy * speed * dt);
      }
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // Znajdowanie komórki pod kursorem
    function getCellAt(x, y) {
      for (const cell of hexMap) {
        const pos = evenr_to_pixel(cell);
        const centerX = pos.x + canvas.width/2 + offsetX;
        const centerY = pos.y + canvas.height/2 + offsetY;
        const dx = x - centerX;
        const dy = y - centerY;
        if (Math.sqrt(dx*dx + dy*dy) < hexRadius) {
          return cell;
        }
      }
      return null;
    }

    function isBlockedForObjects(cell) {
      const terrain = cellDefinitions[cell.id];
      return ['Mountains','Water','Ocean'].includes(terrain.name);
    }

    // Malowanie komórek – obsługa narzędzi: pencil, big-pencil, bucket, eraser
    function paintCell(cell) {
      if (selectedTool === 'bucket') {
        if (cell.id === selectedTerrainId) return;
        const targetId = cell.id;
        const queue = [cell];
        while (queue.length) {
          const current = queue.pop();
          if (current.id === targetId) {
            current.id = selectedTerrainId;
            if (['Mountains','Water','Ocean'].includes(cellDefinitions[selectedTerrainId].name) && current.objectId) {
              current.objectId = 0;
            }
            const neighbors = hexMap.filter(c => {
              const dcol = Math.abs(c.col - current.col);
              const drow = Math.abs(c.row - current.row);
              return dcol <= 1 && drow <= 1;
            });
            queue.push(...neighbors.filter(c => c.id === targetId));
          }
        }
        mapDirty = true;
        saveHistory();
        drawMap();
      } else if (selectedTool === 'pencil') {
        if (drawMode === 'color') {
          if (cell.id === selectedTerrainId) return;
          if (['Mountains','Water','Ocean'].includes(cellDefinitions[selectedTerrainId].name) && cell.objectId) {
            cell.objectId = 0;
          }
          cell.id = selectedTerrainId;
        } else if (drawMode === 'object') {
          if (!selectedObjectId) return;
          if (isBlockedForObjects(cell)) return;
          if (cell.objectId === selectedObjectId) return;
          cell.objectId = selectedObjectId;
        }
        mapDirty = true;
        saveHistory();
        drawMap();
      } else if (selectedTool === 'big-pencil') {
        if (cell.id === selectedTerrainId) return;
        cell.id = selectedTerrainId;
        let neighbors;
        if (cell.row % 2 === 0) {
          neighbors = [
            { col: cell.col + 1, row: cell.row },
            { col: cell.col + 1, row: cell.row - 1 },
            { col: cell.col,     row: cell.row - 1 },
            { col: cell.col - 1, row: cell.row },
            { col: cell.col,     row: cell.row + 1 },
            { col: cell.col + 1, row: cell.row + 1 }
          ];
        } else {
          neighbors = [
            { col: cell.col + 1, row: cell.row },
            { col: cell.col,     row: cell.row - 1 },
            { col: cell.col - 1, row: cell.row - 1 },
            { col: cell.col - 1, row: cell.row },
            { col: cell.col - 1, row: cell.row + 1 },
            { col: cell.col,     row: cell.row + 1 }
          ];
        }
        neighbors.forEach(neighborPos => {
          const neighborCell = hexMap.find(c => c.col === neighborPos.col && c.row === neighborPos.row);
          if (neighborCell) {
            neighborCell.id = selectedTerrainId;
          }
        });
        mapDirty = true;
        saveHistory();
        drawMap();
      } else if (selectedTool === 'eraser') {
        if (drawMode === 'object') {
          if (cell.objectId === 0) return;
          cell.objectId = 0;
        } else {
          if (cell.id === 0) return;
          cell.id = 0;
        }
        mapDirty = true;
        saveHistory();
        drawMap();
      }
    }

    // Obsługa przycisków narzędziowych
    const toolButtons = document.querySelectorAll('.tool-button');
    toolButtons.forEach(button => {
      button.addEventListener('click', () => {
        selectedTool = button.dataset.tool;
        canvas.style.cursor = `url('assets/cursors/${selectedTool}.svg') 0 32, auto`;
        toolButtons.forEach(btn => btn.classList.remove('selected'));
        button.classList.add('selected');
      });
    });
    // Aktualizacja widoczności list terenów/obiektów zależnie od trybu
    function updateListVisibility() {
      if (drawMode === 'color') {
        terrainList.style.display = 'block';
        objectList.style.display = 'none';
        toolButtons.forEach(tool => tool.style.display = 'block');
        document.querySelector('[data-tool="eraser"]').style.display = 'none';
      } else {
        terrainList.style.display = 'none';
        objectList.style.display = 'block';
        toolButtons.forEach(tool => tool.style.display = 'none');
        const moveTool = document.querySelector('[data-tool="move"]');
        const pencilTool = document.querySelector('[data-tool="pencil"]');
        const eraserTool = document.querySelector('[data-tool="eraser"]');
        if (moveTool) moveTool.style.display = 'block';
        if (pencilTool) pencilTool.style.display = 'block';
        if (eraserTool) eraserTool.style.display = 'block';
      }
      selectedTool = 'move';
      canvas.style.cursor = `url('assets/cursors/move.svg') 0 32, auto`;
      toolButtons.forEach(btn => btn.classList.remove('selected'));
      const moveBtn = document.querySelector(".tool-button[data-tool='move']");
      if (moveBtn) moveBtn.classList.add('selected');
    }
    switchModeButton.addEventListener('click', () => {
      drawMode = drawMode === 'color' ? 'object' : 'color';
      switchModeButton.textContent = `Mode: ${drawMode === 'color' ? 'Colors' : 'Objects'}`;
      updateListVisibility();
    });
    // UI – Lista terenów
    cellDefinitions.forEach((terrain, index) => {
      const tile = document.createElement('div');
      tile.classList.add('tile');
      tile.dataset.terrainId = index;
      const colorBox = document.createElement('div');
      colorBox.classList.add('tile-color');
      colorBox.style.backgroundColor = terrain.color;
      const label = document.createElement('span');
      label.textContent = terrain.name;
      tile.appendChild(colorBox);
      tile.appendChild(label);
      terrainList.appendChild(tile);
      tile.addEventListener('click', () => {
        selectedTerrainId = parseInt(tile.dataset.terrainId);
        document.querySelectorAll('#terrainList .tile').forEach(t => t.classList.remove('selected'));
        tile.classList.add('selected');
      });
      if (index === selectedTerrainId) {
        tile.classList.add('selected');
      }
    });
    // UI – Lista obiektów
    objectDefinitions.forEach((obj, index) => {
      const tile = document.createElement('div');
      tile.classList.add('tile');
      tile.dataset.objectId = index + 1;
      const flagContainer = document.createElement('div');
      flagContainer.classList.add('tile-flag');
      const flagImage = document.createElement('img');
      const flagPath = './assets/flags/' + obj.name + '.svg';
      flagImage.src = flagPath;
      flagImage.alt = `${obj.name} flag`;
      flagContainer.appendChild(flagImage);
      const label = document.createElement('span');
      label.textContent = obj.name;
      tile.appendChild(flagContainer);
      tile.appendChild(label);
      objectList.appendChild(tile);
      tile.addEventListener('click', () => {
        selectedObjectId = parseInt(tile.dataset.objectId);
        document.querySelectorAll('#objectList .tile').forEach(t => t.classList.remove('selected'));
        tile.classList.add('selected');
      });
      if (index + 1 === selectedObjectId) {
        tile.classList.add('selected');
      }
    });
    // Ładowanie obrazków SVG z cache
    function loadImage(imagePath, callback) {
      if (imageCache[imagePath]) {
        callback(imageCache[imagePath]);
        return;
      }
      fetch(imagePath)
        .then(response => response.text())
        .then(data => {
          const svgBlob = new Blob([data], { type: 'image/svg+xml;charset=utf-8' });
          const url = URL.createObjectURL(svgBlob);
          const image = new Image();
          image.onload = function () {
            imageCache[imagePath] = image;
            callback(image);
            URL.revokeObjectURL(url);
          };
          image.src = url;
        })
        .catch(error => console.error('Error loading image:', error));
    }
    function getImage(imagePath) {
      return imageCache[imagePath];
    }
    // Inicjalizacja mapy – tworzymy komórki
    function initHexMap() {
      hexMap.length = 0;
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          hexMap.push({ col, row, id: 0, objectId: 0 });
        }
      }
      recalcCenterOffsets();
      mapDirty = true;
      drawMap();
      saveHistory();
    }
    initHexMap();

    // Resize map – przebudowa mapy wg podanej liczby kolumn/wierszy
    resizeButton.addEventListener('click', () => {
      cols = parseInt(colsInput.value);
      rows = parseInt(rowsInput.value);
      if (cols < 5) cols = 5;
      if (rows < 5) rows = 5;
      if (cols > 300) cols = 300;
      if (rows > 200) rows = 200;
      initHexMap();
    });
    // Import / Export danych
    exportButton.addEventListener('click', () => {
      const data = {
        title,
        description,
        cols,
        rows,
        cellDefinitions,
        objectDefinitions,
        cells: hexMap
      };
      const dataStr = JSON.stringify(data, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'hexMap.json';
      a.click();
      URL.revokeObjectURL(url);
    });
    importButton.addEventListener('click', () => {
      fileInput.click();
    });
    fileInput.addEventListener('change', event => {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = e => {
          const json = JSON.parse(e.target.result);
          cols = json.cols || cols;
          rows = json.rows || rows;
          hexMap.length = 0;
          json.cells.forEach(cell => {
            if (cell.col === undefined) cell.col = 0;
            if (cell.row === undefined) cell.row = 0;
            if (cell.id === undefined) cell.id = 0;
            if (cell.objectId === undefined) cell.objectId = 0;
            hexMap.push(cell);
          });
          recalcCenterOffsets();
          mapDirty = true;
          drawMap();
          saveHistory();
        };
        reader.readAsText(file);
      }
    });
    // Obsługa zmiany rozmiaru hexów (zoom)
    function updateHexSize(newSize) {
      hexRadius = newSize;
      hexWidth = Math.sqrt(3) * hexRadius;
      hexHeight = 2 * hexRadius;
      const baseGap = Math.max(1, hexRadius * 0.1);
      gap = baseGap / zoomLevel;
      hexHorizontalSpacing = hexWidth + gap;
      hexVerticalSpacing = hexHeight * 0.75 + gap;
      recalcCenterOffsets();
      mapDirty = true;
      drawMap();
    }
    hexSizeInput.addEventListener('input', (event) => {
      updateHexSize(parseInt(event.target.value));
    });
    zoomInButton.addEventListener('click', () => {
      let current = parseInt(hexSizeInput.value);
      if (current < parseInt(hexSizeInput.max)) {
        current++;
        hexSizeInput.value = current;
        zoomLevel *= 1.2;
        updateHexSize(current);
      }
    });
    zoomOutButton.addEventListener('click', () => {
      let current = parseInt(hexSizeInput.value);
      if (current > parseInt(hexSizeInput.min)) {
        current--;
        hexSizeInput.value = current;
        zoomLevel /= 1.2;
        updateHexSize(current);
      }
    });
    updateListVisibility();
    resizeCanvas();
  </script>
</body>
</html>
