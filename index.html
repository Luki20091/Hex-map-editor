<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Zablokowanie przybliżania/oddalania strony przez przeglądarkę -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Hex Map Editor - BETA 1.4.1</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/js/all.min.js" crossorigin="anonymous" type="text/javascript"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      display: flex;
      overflow: hidden;
    }
    canvas {
      display: block;
      background-color: #111111;
      cursor: url('assets/cursors/pencil.svg') 0 32, auto;
      height: min-content;
      width: min-content;
    }
    #controls {
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 8px;
      width: 240px;
      overflow-y: auto;
      max-height: 100vh;
      box-shadow: -2px 0 5px rgba(0, 0, 0, 0.2);
      position: fixed;
    }
    .tile {
      display: flex;
      align-items: center;
      margin: 5px 0;
      cursor: pointer;
      padding: 5px;
      border-radius: 4px;
      transition: ease-in-out background 0.2s;
    }
    .tile:hover {
      background: rgba(0, 0, 0, 0.1);
    }
    .tile.selected {
      background: rgba(0, 123, 255, 0.2);
    }
    .tile-color {
      height: 24px;
      margin-right: 10px;
      aspect-ratio: 1;
      clip-path: polygon(-50% 50%,50% 100%,150% 50%,50% 0);
    }
    .tile-flag img {
      height: 24px;
      margin-right: 10px;
    }
    button {
      display: block;
      margin: 10px 0;
      padding: 5px 10px;
      border: none;
      background: #007BFF;
      color: #fff;
      cursor: pointer;
      border-radius: 4px;
    }
    button:hover {
      background: #0056b3;
    }
    .tool-button {
      margin: 5px 0;
      padding: 10px;
      border: none;
      background: #007BFF;
      color: #fff;
      cursor: pointer;
      border-radius: 4px;
      display: block;
      font-size: 20px;
      text-align: center;
    }
    .tool-button.selected {
      background: #0056b3;
    }
    .input-group {
      margin: 10px 0;
    }
    input[type="number"],
    input[type="range"] {
      width: 100%;
      padding: 5px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
  </style>
</head>
<body>
  <canvas id="hexCanvas"></canvas>
  <div id="controls">
    <button id="switchModeButton">Mode: Colors</button>
    <div id="terrainList"></div>
    <div id="objectList"></div>
    <button class="tool-button selected" data-tool="move"><i class="fas fa-arrows-alt"></i></button>
    <button class="tool-button" data-tool="pencil"><i class="fas fa-pencil"></i></button>
    <button class="tool-button" data-tool="big-pencil"><i class="fa-solid fa-paintbrush"></i></button>
    <button class="tool-button" data-tool="bucket"><i class="fa-solid fa-fill-drip fa-flip-horizontal"></i></button>
    <button class="tool-button" data-tool="eraser"><i class="fa-solid fa-eraser"></i></button>
    <button id="resetButton">Reset Map</button>
    <button id="exportButton">Export to JSON</button>
    <button id="importButton">Import from JSON</button>
    <button id="undoButton">Undo</button>
    <button id="redoButton">Redo</button>
    <input type="file" id="fileInput" style="display:none;">
    <div class="input-group">
      <label for="cols">Columns: </label>
      <input type="number" id="cols" value="29" min="5" max="60" />
    </div>
    <div class="input-group">
      <label for="rows">Rows: </label>
      <input type="number" id="rows" value="17" min="5" max="40" />
    </div>
    <!-- Sterowanie zoomem mapy (rozmiarem hexów) -->
    <div class="input-group">
      <label for="hexSize">Hex Size (Zoom):</label>
      <input type="range" id="hexSize" min="10" max="50" value="25">
    </div>
    <button id="zoomInButton">Zoom In</button>
    <button id="zoomOutButton">Zoom Out</button>
    <button id="resizeButton">Resize Map</button>
  </div>

  <script>
    // =======================
    // Zmienne globalne i ustawienia
    // =======================
    const canvas = document.getElementById("hexCanvas");
    const ctx = canvas.getContext("2d");
    const exportButton = document.getElementById("exportButton");
    const importButton = document.getElementById("importButton");
    const fileInput = document.getElementById("fileInput");
    const terrainList = document.getElementById("terrainList");
    const objectList = document.getElementById("objectList");
    const undoButton = document.getElementById("undoButton");
    const redoButton = document.getElementById("redoButton");
    const resetButton = document.getElementById("resetButton");
    const resizeButton = document.getElementById("resizeButton");
    const colsInput = document.getElementById("cols");
    const rowsInput = document.getElementById("rows");
    const hexSizeInput = document.getElementById("hexSize");
    const zoomInButton = document.getElementById("zoomInButton");
    const zoomOutButton = document.getElementById("zoomOutButton");

    // Inicjalizacja rozmiaru hexów
    let hexRadius = parseInt(hexSizeInput.value);
    let hexWidth = Math.sqrt(3) * hexRadius;
    let hexHeight = 2 * hexRadius;
    // Obliczamy odstęp (gap) – przyjmujemy 10% hexRadius, minimum 1px
    let gap = Math.max(1, hexRadius * 0.1);
    let hexHorizontalSpacing = hexWidth + gap;
    let hexVerticalSpacing = hexHeight * 0.75 + gap;

    let cols = 29;
    let rows = 17;
    const hexMap = [];
    let selectedColor = "";
    let isPainting = false;
    let selectedTool = "move";
    let selectedObject = null;
    let drawMode = "color"; // Możliwe wartości: "color", "object"
    let history = [];
    let historyIndex = -1;

    // =======================
    // Definicje terenów i obiektów
    // =======================
    const terrains = [
      { name: "Desert", color: "#FFD700" },
      { name: "Cactus Desert", color: "#CD853F" },
      { name: "Dunes", color: "#F0E68C" },
      { name: "Mountains", color: "#777777" },
      { name: "Forest", color: "#1a7a1a" },
      { name: "Meadow", color: "#00bb00" },
      { name: "Grassland", color: "#7FFF00" },
      { name: "Jungle", color: "#228B66" },
      { name: "Swamp", color: "#3fabaa" },
      { name: "Highlands", color: "#6B8E23" },
      { name: "Snowfield", color: "#FFFFFF" },
      { name: "Snowy Forest", color: "#87ddEB" },
      { name: "Glacier", color: "#4682B4" },
      { name: "Water", color: "#3fabff" },
      { name: "Ocean", color: "#325ddb" }
    ];

    const objects = [
      { name: "Poland", id: 1},
      { name: "Germany", id: 2}
    ];

    // =======================
    // Tworzenie listy terenów
    // =======================
    terrains.forEach(terrain => {
      const tile = document.createElement("div");
      tile.classList.add("tile");
      tile.dataset.color = terrain.color;

      const colorBox = document.createElement("div");
      colorBox.classList.add("tile-color");
      colorBox.style.backgroundColor = terrain.color;

      const label = document.createElement("span");
      label.textContent = terrain.name;

      tile.appendChild(colorBox);
      tile.appendChild(label);
      terrainList.appendChild(tile);

      tile.addEventListener("click", () => {
        selectedColor = terrain.color;
        document.querySelectorAll(".tile").forEach(t => t.classList.remove("selected"));
        tile.classList.add("selected");
      });
    });

    // =======================
    // Tworzenie listy obiektów
    // =======================
    objects.forEach(object => {
      const tile = document.createElement("div");
      tile.classList.add("tile");
      tile.dataset.object = object.id;

      const flagContainer = document.createElement("div");
      flagContainer.classList.add("tile-flag");

      const flagImage = document.createElement("img");
      const flagPath = "./assets/flags/" + object.name + ".svg"; 
      flagImage.src = flagPath;
      flagImage.alt = `${object.name} flag`;

      flagContainer.appendChild(flagImage);

      const label = document.createElement("span");
      label.textContent = object.name;

      tile.appendChild(flagContainer);
      tile.appendChild(label);
      objectList.appendChild(tile);

      tile.addEventListener("click", () => {
        selectedObject = object.id;
        document.querySelectorAll("#objectList .tile").forEach(t => t.classList.remove("selected"));
        tile.classList.add("selected");
      });
    });

    // =======================
    // Ustawienie początkowego zaznaczenia terenu (jeśli pasuje)
    // =======================
    document.querySelectorAll(".tile").forEach(tile => {
      if (tile.dataset.color === selectedColor) {
        tile.classList.add("selected");
      }
    });

    // =======================
    // Funkcje obsługujące rysowanie mapy i interakcje
    // =======================

    /**
     * Funkcja przelicza współrzędne heksagonu na piksele.
     * Używamy teraz właściwości col oraz row.
     */
    function evenr_to_pixel(hex) {
      const offset = hex.row % 2 === 0 ? 0.5 : 0;
      const x = hexRadius * Math.sqrt(3) * (hex.col + offset);
      const y = hexRadius * (3 / 2) * hex.row;
      return { x, y };
    }

    // Funkcja do rysowania pojedynczego hexagonu
    function drawHex(x, y, color = "#BBBBBB") {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 3 * i + Math.PI / 6;
        const xOffset = x + Math.cos(angle) * hexRadius;
        const yOffset = y + Math.sin(angle) * hexRadius;
        ctx.lineTo(xOffset, yOffset);
      }
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
      ctx.strokeStyle = "#333333";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // Funkcja do rysowania granic mapy
    function drawBorder() {
      for (let row = -1; row <= rows; row++) {
        for (let col = -1; col <= cols; col++) {
          if (row === -1 || row === rows || col === -1 || col === cols) {
            const { x, y } = evenr_to_pixel({ col, row });
            drawHex(x + canvas.width / 2 + offsetX, y + canvas.height / 2 + offsetY, "#111111");
          }
        }
      }
    }

    function drawMap() {
        // Czyścimy canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBorder();

        // Iterujemy po wszystkich heksach z hexMap
        hexMap.forEach(hex => {
            const { x, y } = evenr_to_pixel(hex);
            const screenX = x + canvas.width / 2 + offsetX;
            const screenY = y + canvas.height / 2 + offsetY;

            if (
                screenX + hexRadius *2 < 0 ||
                screenX - hexRadius *2 > canvas.width ||
                screenY + hexRadius *2 < 0 ||
                screenY - hexRadius *2 > canvas.height
            ) {
                return;
            }

            drawHex(screenX, screenY, hex.color);

            if (hex.object) {
                const object = objects.find(c => c.id === hex.object);
                if (object) {
                    const flagPath = "./assets/flags/" + object.name + ".svg";
                    const image = getImage(flagPath);
                    if (image) {
                        ctx.drawImage(
                            image,
                            screenX - hexRadius / 2,
                            screenY - hexRadius / 2,
                            hexRadius,
                            hexRadius
                        );
                    } else {
                        loadImage(flagPath, (loadedImage) => {
                            ctx.drawImage(
                                loadedImage,
                                screenX - hexRadius / 2,
                                screenY - hexRadius / 2,
                                hexRadius,
                                hexRadius
                            );
                        });
                    }
                }
            }
        });
    }

    // Funkcje zapisu stanu mapy (undo/redo)
    function saveHistory() {
      history.length = historyIndex + 1;
      history.push(JSON.parse(JSON.stringify(hexMap)));
      historyIndex++;
    }

    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        hexMap.length = 0;
        hexMap.push(...JSON.parse(JSON.stringify(history[historyIndex])));
        drawMap();
      }
    }

    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        hexMap.length = 0;
        hexMap.push(...JSON.parse(JSON.stringify(history[historyIndex])));
        drawMap();
      }
    }

    // =======================
    // Obsługa zdarzeń myszy i klawiatury
    // =======================
    let offsetX = -canvas.width * 2;
    let offsetY = -canvas.height * 2;

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      drawMap();
    }

    window.addEventListener("resize", resizeCanvas);

    function moveMap(dx, dy) {
      offsetX += dx;
      offsetY += dy;
      drawMap();
    }

    let isMouseDown = false;
    const moveSpeed = 20;
    canvas.addEventListener("mousedown", (event) => {
      if (selectedTool === "move") {
        isMouseDown = true;
        canvas.style.cursor = `url('assets/cursors/${selectedTool}2.svg') 0 32, auto`;
      }
    });
    canvas.addEventListener("mouseup", () => {
      isMouseDown = false;
      canvas.style.cursor = `url('assets/cursors/${selectedTool}.svg') 0 32, auto`;
      isPainting = false;
    });
    canvas.addEventListener("mouseleave", () => {
      isMouseDown = false;
      isPainting = false;
    });
    canvas.addEventListener("mousemove", (event) => {
      if (selectedTool === "move" && isMouseDown) {
        moveMap(event.movementX, event.movementY);
      } else if (isPainting) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        const hex = getHexAt(mouseX, mouseY);
        if (hex) paintHex(hex);
      }
    });

    document.addEventListener("keydown", (event) => {
      if (event.key === 'w' || event.key === 'ArrowUp') {
        moveMap(0, moveSpeed);
      } else if (event.key === 'a' || event.key === 'ArrowLeft') {
        moveMap(moveSpeed, 0);
      } else if (event.key === 's' || event.key === 'ArrowDown') {
        moveMap(0, -moveSpeed);
      } else if (event.key === 'd' || event.key === 'ArrowRight') {
        moveMap(-moveSpeed, 0);
      }
      if (event.ctrlKey && event.key === "z") {
        event.preventDefault();
        undo();
      }
      if (event.ctrlKey && event.key === "y") {
        event.preventDefault();
        redo();
      }
    });

    // Funkcja wyznaczająca hexagon pod kursorem
    function getHexAt(x, y) {
      const mouseX = x;
      const mouseY = y;
      let foundHex = null;
      for (const hex of hexMap) {
        const { x: hx, y: hy } = evenr_to_pixel(hex);
        const centerX = hx + canvas.width / 2 + offsetX;
        const centerY = hy + canvas.height / 2 + offsetY;
        const dx = mouseX - centerX;
        const dy = mouseY - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < hexRadius) {
          foundHex = hex;
          break;
        }
      }
      return foundHex;
    }

    // =======================
    // Malowanie hexagonów – narzędzia: pencil, big-pencil, bucket, eraser
    // =======================
    function paintHex(hex) {
      if (selectedTool === "bucket") {
        if (hex.color === selectedColor) return;
        const targetColor = hex.color;
        const queue = [hex];
        while (queue.length) {
          const current = queue.pop();
          if (current.color === targetColor) {
            current.color = selectedColor;
            if (blockedColors.includes(selectedColor) && current.object !== 0) {
              current.object = 0;
            }
            const neighbors = hexMap.filter(h => {
              const dcol = Math.abs(h.col - current.col);
              const drow = Math.abs(h.row - current.row);
              return dcol <= 1 && drow <= 1;
            });
            queue.push(...neighbors.filter(h => h.color === targetColor));
          }
        }
        saveHistory();
        drawMap();
      } else if (selectedTool === "pencil") {
        if (drawMode === "color") {
          if (hex.color === selectedColor) return;
          if (blockedColors.includes(selectedColor) && hex.object !== 0) hex.object = 0;
          hex.color = selectedColor;
        } else if (drawMode === "object") {
          if (!selectedObject) return;
          if (isBlockedForObjects(hex)) return;
          hex.object = selectedObject;
        }
        saveHistory();
        drawMap();
      } else if (selectedTool === "big-pencil") {
        // Centralny hex malujemy wybranym kolorem
        hex.color = selectedColor;
        let neighbors;
        if (hex.row % 2 === 0) { // wiersz parzysty
          neighbors = [
            { col: hex.col + 1, row: hex.row },
            { col: hex.col + 1, row: hex.row - 1 },
            { col: hex.col,     row: hex.row - 1 },
            { col: hex.col - 1, row: hex.row },
            { col: hex.col,     row: hex.row + 1 },
            { col: hex.col + 1, row: hex.row + 1 }
          ];
        } else { // wiersz nieparzysty
          neighbors = [
            { col: hex.col + 1, row: hex.row },
            { col: hex.col,     row: hex.row - 1 },
            { col: hex.col - 1, row: hex.row - 1 },
            { col: hex.col - 1, row: hex.row },
            { col: hex.col - 1, row: hex.row + 1 },
            { col: hex.col,     row: hex.row + 1 }
          ];
        }
        //const testColors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];
        neighbors.forEach((neighbor, index) => {
          const neighborHex = hexMap.find(h => h.col === neighbor.col && h.row === neighbor.row);
          if (neighborHex) {
            //neighborHex.color = testColors[index] || selectedColor;
            neighborHex.color = selectedColor;
          }
        });
        saveHistory();
        drawMap();
      }
    }

    canvas.addEventListener("mouseup", () => { isPainting = false; });
    canvas.addEventListener("mouseleave", () => { isPainting = false; });
    canvas.addEventListener("mousedown", event => {
      if (selectedTool !== "move") {
        isPainting = true;
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        const hex = getHexAt(mouseX, mouseY);
        if (hex) paintHex(hex);
      }
    });

    // =======================
    // Funkcje pomocnicze dla terenów i blokad obiektów
    // =======================
    function getTerrainColorByName(name) {
      const terrain = terrains.find(terrain => terrain.name === name);
      return terrain ? terrain.color : null;
    }

    const blockedColors = [
      getTerrainColorByName("Mountains"),
      getTerrainColorByName("Water"),
      getTerrainColorByName("Ocean")
    ];

    function isBlockedForObjects(hex) {
      return blockedColors.includes(hex.color);
    }

    // =======================
    // Obsługa przycisków narzędziowych
    // =======================
    const toolButtons = document.querySelectorAll(".tool-button");
    toolButtons.forEach(button => {
      button.addEventListener("click", () => {
        setTool(button);
      });
    });

    function setTool(button) {
      selectedTool = button.dataset.tool;
      canvas.style.cursor = `url('assets/cursors/${selectedTool}.svg') 0 32, auto`;
      toolButtons.forEach(btn => btn.classList.remove("selected"));
      button.classList.add("selected");
    }

    // =======================
    // Import / Export / Resize mapy
    // =======================
    let title = "testowy tytuł";
    let description = "testowy opis";

    exportButton.addEventListener("click", () => {
      // Eksportujemy hexMap, tytuł, opis, cols oraz rows.
      // Każdy hex zawiera właściwości: col, row, color oraz object.
      const dataStr = JSON.stringify({ hexMap, title, description, cols, rows }, null, 2);
      const blob = new Blob([dataStr], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "hexMap.json";
      a.click();
      URL.revokeObjectURL(url);
    });

    importButton.addEventListener("click", () => {
      fileInput.click();
    });

    fileInput.addEventListener("change", event => {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = e => {
          const json = JSON.parse(e.target.result);
          cols = json.cols || cols;
          rows = json.rows || rows;
          hexMap.length = 0;
          json.hexMap.forEach(hex => {
            // Jeśli importowany hex ma pola q oraz r, konwertujemy je na col oraz row
            if (hex.col === undefined && hex.q !== undefined) {
              hex.col = hex.q;
              hex.row = hex.r;
            }
            if (hex.col === undefined) {
              hex.col = 0;
            }
            if (hex.row === undefined) {
              hex.row = 0;
            }
            if (hex.object === undefined) {
              hex.object = 0;
            }
            hexMap.push(hex);
          });
          canvas.width = cols * hexHorizontalSpacing + hexWidth / 2;
          canvas.height = rows * hexVerticalSpacing + hexHeight / 2;
          saveHistory();
          resizeCanvas();
          drawMap();
        };
        reader.readAsText(file);
      }
    });

    undoButton.addEventListener("click", undo);
    redoButton.addEventListener("click", redo);

    resizeButton.addEventListener("click", () => {
      cols = parseInt(colsInput.value);
      rows = parseInt(rowsInput.value);
      if (cols < 5) cols = 5;
      if (rows < 5) rows = 5;
      if (cols > 60) cols = 60;
      if (rows > 40) rows = 40;
      hexMap.length = 0;
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          hexMap.push({ col, row, color: "#BBBBBB", object: 0 });
        }
      }
      canvas.width = cols * hexHorizontalSpacing + hexWidth / 2;
      canvas.height = rows * hexVerticalSpacing + hexHeight / 2;
      resizeCanvas();
      drawMap();
    });

    // =======================
    // Aktualizacja widoczności list (terenów/obiektów) w zależności od trybu rysowania
    // =======================
    function updateListVisibility() {
      const colorList = document.getElementById("terrainList");
      const objectList = document.getElementById("objectList");
      const allTools = document.querySelectorAll(".tool-button");
      const moveTool = document.querySelector('[data-tool="move"]');
      const pencilTool = document.querySelector('[data-tool="pencil"]');
      const bigPencilTool = document.querySelector('[data-tool="big-pencil"]');
      const bucketTool = document.querySelector('[data-tool="bucket"]');
      const eraserTool = document.querySelector('[data-tool="eraser"]');

      if (drawMode === "color") {
        colorList.style.display = "block";
        objectList.style.display = "none";
        allTools.forEach(tool => tool.style.display = "block");
        if (eraserTool) eraserTool.style.display = "none";
      } else {
        colorList.style.display = "none";
        objectList.style.display = "block";
        allTools.forEach(tool => tool.style.display = "none");
        if (moveTool) moveTool.style.display = "block";
        if (pencilTool) pencilTool.style.display = "block";
        if (eraserTool) eraserTool.style.display = "block";
      }
      
      setTool(document.querySelector(".tool-button[data-tool='move']"));
    }

    const switchModeButton = document.getElementById("switchModeButton");
    switchModeButton.addEventListener("click", () => {
      drawMode = drawMode === "color" ? "object" : "color";
      switchModeButton.textContent = `Mode: ${drawMode === "color" ? "Colors" : "Objects"}`;
      updateListVisibility();
    });

    // =======================
    // Obsługa ładowania obrazków SVG z pamięcią podręczną
    // =======================
    let imageCache = {};

    function loadImage(imagePath, callback) {
      if (imageCache[imagePath]) {
        callback(imageCache[imagePath]);
        return;
      }
      fetch(imagePath)
        .then(response => response.text())
        .then(data => {
          const svgBlob = new Blob([data], { type: 'image/svg+xml;charset=utf-8' });
          const url = URL.createObjectURL(svgBlob);
          const image = new Image();
          image.onload = function () {
            imageCache[imagePath] = image;
            callback(image);
            URL.revokeObjectURL(url);
          };
          image.src = url;
        })
        .catch(error => console.error("Error loading image:", error));
    }

    function getImage(imagePath) {
      return imageCache[imagePath];
    }

    // =======================
    // Inicjalizacja mapy – używamy właściwości col i row
    // =======================
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        hexMap.push({ col, row, color: "#BBBBBB", object: 0 });
      }
    }

    // =======================
    // Obsługa zmiany rozmiaru hexagonów (sterowanie zoomem mapy)
    // =======================
    let zoomLevel = 1;  // Początkowy poziom zoomu

    function updateHexSize(newSize) {
        hexRadius = newSize;
        hexWidth = Math.sqrt(3) * hexRadius;
        hexHeight = 2 * hexRadius;
        
        // Obliczamy odstęp (gap)
        const baseGap = Math.max(0, hexRadius * 0.1);
        const gap = Math.max(0, baseGap * (1 / zoomLevel));
        
        hexHorizontalSpacing = hexWidth + gap;    
        hexVerticalSpacing = hexHeight * 0.75 + gap;

        resizeCanvas();
        drawMap();
    }

    function zoomIn() {
        zoomLevel *= 1.2;
        updateHexSize(hexRadius);
    }

    function zoomOut() {
        zoomLevel /= 1.2;
        updateHexSize(hexRadius);
    }
    
    hexSizeInput.addEventListener("input", (event) => {
      updateHexSize(parseInt(event.target.value));
    });
    
    zoomInButton.addEventListener("click", () => {
      let current = parseInt(hexSizeInput.value);
      if (current < parseInt(hexSizeInput.max)) {
        current++;
        hexSizeInput.value = current;
        updateHexSize(current);
      }
    });
    
    zoomOutButton.addEventListener("click", () => {
      let current = parseInt(hexSizeInput.value);
      if (current > parseInt(hexSizeInput.min)) {
        current--;
        hexSizeInput.value = current;
        updateHexSize(current);
      }
    });

    resizeCanvas();
    updateListVisibility();
    saveHistory();
    drawMap();
  </script>
</body>
</html>
