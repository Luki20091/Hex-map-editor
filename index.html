<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Disable zooming on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Hex Map Editor - BETA 2.1</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/js/all.min.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" type="text/css" href="assets/styles/desktop.css">
</head>
<body>
  <!-- Main canvas for drawing the hex map -->
  <canvas id="hexCanvas"></canvas>

  <!-- Left Sidebar: Tools, Mode: Colors -->
  <div id="leftSidebarCells" class="leftSidebar">
    <button id="tool-move" class="tool-button" data-tool="move" title="Move (Pan)">
      <i class="fas fa-arrows-alt"></i>
    </button>
    <button id="tool-pencil" class="tool-button" data-tool="pencil" title="Pencil (Paint)">
      <i class="fas fa-pencil-alt"></i>
    </button>
    <button id="tool-big-pencil" class="tool-button" data-tool="big-pencil" title="Big Pencil (Area Paint)">
      <i class="fas fa-paint-brush"></i>
    </button>
    <button id="tool-bucket" class="tool-button" data-tool="bucket" title="Bucket (Fill)">
      <i class="fas fa-fill-drip"></i>
    </button>
  </div>

  <!-- Left Sidebar: Tools, Mode: Objects -->
  <div id="leftSidebarObjects" class="leftSidebar">
    <button id="tool-move" class="tool-button" data-tool="move" title="Move (Pan)">
      <i class="fas fa-arrows-alt"></i>
    </button>
    <button id="tool-pencil" class="tool-button" data-tool="pencil" title="Pencil (Paint)">
      <i class="fas fa-pencil-alt"></i>
    </button>
    <button id="tool-eraser" class="tool-button" data-tool="eraser" title="Eraser (Remove)">
      <i class="fas fa-eraser"></i>
    </button>
  </div>

  <!-- Top Left Panel: Map Settings, Export Form & Generator -->
  <div id="topLeft">
    <div class="map-settings">
      <div class="setting-item">
        <label for="cols"><i class="fas fa-columns"></i> Columns</label>
        <input type="number" id="cols" value="29" min="5" max="200">
      </div>
      <div class="setting-item">
        <label for="rows"><i class="fas fa-th"></i> Rows</label>
        <input type="number" id="rows" value="17" min="5" max="150">
      </div>
      <div class="setting-item">
        <button id="resizeButton" title="Resize Map"><i class="fas fa-expand"></i> Resize</button>
      </div>
      <div class="setting-item">
        <button id="resetButton" title="Reset Map"><i class="fas fa-sync-alt"></i> Reset</button>
      </div>
    </div>
    <div class="export-form">
      <div class="setting-item">
        <label for="mapTitle"><i class="fas fa-font"></i> Title</label>
        <input type="text" id="mapTitle" placeholder="Map title" minlength="5" maxlength="30" pattern="[A-Za-z0-9-]{5,30}" required>
      </div>
      <div class="setting-item">
        <label for="mapDescription"><i class="fas fa-info-circle"></i> Description</label>
        <input type="text" id="mapDescription" placeholder="Map description" minlength="5" maxlength="100" pattern="[A-Za-z0-9-\s]{5,100}" required>
      </div>
      <div class="setting-item">
        <button id="importButton" title="Import from JSON"><i class="fas fa-file-import"></i> Import</button>
        <input type="file" id="fileInput" style="display:none;">
      </div>
      <div class="setting-item">
        <button id="exportButton" title="Export to JSON"><i class="fas fa-file-export"></i> Export</button>
      </div>
      <div class="setting-item">
        <button id="exportImg" title="Export map as img with coordinates"><i class="fas fa-file-image"></i> Img Export</button>
      </div>
      <div class="setting-item">
        <button id="aiGenerateButton" title="Generate Map with AI"><i class="fas fa-robot"></i> AI Generate</button>
      </div>
    </div>
  </div>

  <!-- Right Sidebar: Tile Palette (Colors and Objects) -->
  <div id="rightSidebar">
    <button id="switchModeButton" title="Switch between Colors and Objects">
      <i class="fas fa-exchange-alt"></i> Mode: Colors
    </button>
    <div id="terrainList"></div>
    <!--<div id="nationList" style="display:none;"></div>-->
    <div id="teamList" style="display:none;"></div>
  </div>

  <!-- Bottom Left Panel: Big Pencil Slider -->
  <div id="bottomLeft">
    <div class="slider-container">
      <label for="bigBrushSize"><i class="fas fa-brush"></i> Big Brush Size</label>
      <input type="range" id="bigBrushSize" min="1" max="10" value="1">
    </div>
    <div class="slider-container">
      <label for="bigBrushRoughness"><i class="fas fa-random"></i> Jaggedness</label>
      <input type="range" id="bigBrushRoughness" min="0" max="9" value="0">
    </div>
  </div>

  <!-- Bottom Center Panel: Zoom Controls -->
  <div id="bottomCenter">
    <button id="zoomOutButton" title="Zoom Out">
      <i class="fas fa-search-minus"></i>
    </button>
    <input type="range" id="hexSize" min="2" max="50" value="19">
    <button id="zoomInButton" title="Zoom In">
      <i class="fas fa-search-plus"></i>
    </button>
  </div>

  <!-- Bottom Right Panel: Undo / Redo -->
  <div id="bottomRight">
    <button id="undoButton" title="Undo">
      <i class="fas fa-undo"></i>
    </button>
    <button id="redoButton" title="Redo">
      <i class="fas fa-redo"></i>
    </button>
  </div>

  <script>
    // Prevent accidental refresh/quit
    window.addEventListener("beforeunload", function(e) {
      e.preventDefault();
      e.returnValue = '';
    });

    /* =================== GLOBAL DECLARATIONS =================== */
    const canvas = document.getElementById('hexCanvas');
    const ctx = canvas.getContext('2d');
    const exportButton = document.getElementById('exportButton');
    const importButton = document.getElementById('importButton');
    const fileInput = document.getElementById('fileInput');
    const colsInput = document.getElementById('cols');
    const rowsInput = document.getElementById('rows');
    const hexSizeInput = document.getElementById('hexSize');
    const zoomInButton = document.getElementById('zoomInButton');
    const zoomOutButton = document.getElementById('zoomOutButton');
    const resetButton = document.getElementById('resetButton');
    const resizeButton = document.getElementById('resizeButton');
    const switchModeButton = document.getElementById('switchModeButton');
    const bigBrushSizeInput = document.getElementById('bigBrushSize');
    const mapTitleInput = document.getElementById('mapTitle');
    const mapDescriptionInput = document.getElementById('mapDescription');

    /* =================== BIG PENCIL SIZE SETUP =================== */
    let bigBrushSize = parseInt(bigBrushSizeInput.value);
    bigBrushSizeInput.addEventListener('input', (event) => {
      bigBrushSize = parseInt(event.target.value);
    });
    let bigBrushRoughness = parseInt(document.getElementById('bigBrushRoughness').value);
    document.getElementById('bigBrushRoughness').addEventListener('input', (event) => {
      bigBrushRoughness = parseInt(event.target.value);
    });

    // Cell, Nation and Object Definitions
    const cellDefinitions = [
      { id: 0, name: "Ocean", color: "#325ddb" },
      { id: 1, name: "Water", color: "#3fabff" },
      { id: 4, name: "Sands", color: "#F0E68C" },
      { id: 8, name: "Grassland", color: "#7FFF00" },
      { id: 7, name: "Meadow", color: "#00bb00" },
      { id: 6, name: "Forest", color: "#1a7a1a" },
      { id: 9, name: "Jungle", color: "#228B66" },
      { id: 11, name: "Highlands", color: "#6B8E23" },
      { id: 5, name: "Mountains", color: "#777777" },
      { id: 15, name: "High Mountains", color: "#9e9e9e" },
      { id: 16, name: "Snowy Mountains", color: "#f2f2f2" },
      { id: 17, name: "Volcanic  Mountains", color: "#8c4343" },
      { id: 10, name: "Swamp", color: "#3fabaa" },
      { id: 2, name: "Desert", color: "#d6c047" },
      { id: 3, name: "Cactus Desert", color: "#CD853F" },
      { id: 12, name: "Snowfield", color: "#FFFFFF" },
      { id: 13, name: "Snowy Forest", color: "#87ddEB" },
      { id: 14, name: "Glacier", color: "#4682B4" }
    ];
    const nationDefinitions = [ 
      { id: 1, name: "Unnational" },
      { id: 2, name: "UN" },
      { id: 3, name: "Poland" },
      { id: 4, name: "Germany" },
      { id: 5, name: "Nazi-Germany" },
      { id: 6, name: "England" },
      { id: 8, name: "Royal-England" },
      { id: 7, name: "UK" },
      { id: 9, name: "France" },
      { id: 10, name: "Gallic" },
      { id: 11, name: "Greece" },
      { id: 12, name: "Italy" },
      { id: 13, name: "Teutonic" },
      { id: 14, name: "Rome" },
      { id: 15, name: "USA" },
      { id: 16, name: "Mexico" },
      { id: 17, name: "China" },
      { id: 18, name: "Arabia" },
      { id: 19, name: "Persia" },
      { id: 20, name: "ZSRR" }
    ];
    const objectDefinitions = [
      { id: 1, name: "City" },
      { id: 2, name: "Industry" },
      { id: 3, name: "Village" },
      { id: 4, name: "Infantry" },
      { id: 5, name: "Ranged" },
      { id: 6, name: "Cavalry" }
    ];

    let selectedTerrainId = 1;
    let selectedObjectId = 1;
    let selectedNationId = 1;
    let drawMode = "color";
    let selectedTool = "move";
    let history = [];
    let historyIndex = -1;
    let cols = 29;
    let rows = 17;
    const hexMap = [];
    let hexRadius = parseInt(hexSizeInput.value);
    let hexWidth = Math.sqrt(3) * hexRadius;
    let hexHeight = 2 * hexRadius;
    let gap = true;
    let hexHorizontalSpacing = hexWidth;
    let hexVerticalSpacing = hexHeight * 0.75;
    let offsetX = 0;
    let offsetY = 0;
    let zoomLevel = 1;
    const keysPressed = {};
    let lastTime = performance.now();
    let imageCache = {};
    let title = "Title";
    let description = "Descripton";

    // CHUNKING VARIABLES
    let chunkSize = 10;
    let chunkCache = new Map();
    let superChunkCache = new Map();
    let mapDirty = true;
    let dirtyChunks = new Set();

    /* ---------------------------------------------------------------------------
     * Funkcje setCursor i setTool – Ustawiają kursor oraz aktualne narzędzie
     * ------------------------------------------------------------------------- */
    function setCursor(toolName) {
      canvas.style.cursor = `url('assets/cursors/${toolName}.svg') 2 30, auto`;
    }
    function setTool(toolName) {
      selectedTool = toolName;
      setCursor(toolName);
    }

    /* ---------------------------------------------------------------------------
     * Group 2: Chunking Functions
     * ------------------------------------------------------------------------- */
    function computeChunkSize() {
      const totalCells = cols * rows;
      return totalCells > 500 ? 20 : 10;
    }
    function getChunkKey(col, row) {
      return Math.floor(col / chunkSize) + '_' + Math.floor(row / chunkSize);
    }
    function updateChunk(chunkKey, chunkCells) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      chunkCells.forEach(cell => {
        const pos = evenr_to_pixel(cell);
        if (pos.x < minX) minX = pos.x;
        if (pos.x > maxX) maxX = pos.x;
        if (pos.y < minY) minY = pos.y;
        if (pos.y > maxY) maxY = pos.y;
      });
      minX = Math.floor(minX - hexRadius - (gap ? 0 : 2));
      minY = Math.floor(minY - hexRadius - (gap ? 0 : 2));
      maxX = Math.ceil(maxX + hexRadius + (gap ? 0 : 2));
      maxY = Math.ceil(maxY + hexRadius + (gap ? 0 : 2));
      const width = maxX - minX;
      const height = maxY - minY;
      const offscreen = document.createElement('canvas');
      offscreen.width = width;
      offscreen.height = height;
      const offCtx = offscreen.getContext('2d');
      const terrainGroups = {};
      chunkCells.forEach(cell => {
        const pos = evenr_to_pixel(cell);
        const relX = pos.x - minX;
        const relY = pos.y - minY;
        const terrainId = cell.id;
        if (!terrainGroups[terrainId]) {
          terrainGroups[terrainId] = new Path2D();
        }
        const hexPath = new Path2D();
        for (let i = 0; i < 6; i++) {
          const angle = Math.PI / 3 * i + Math.PI / 6;
          const xOffset = relX + Math.cos(angle) * hexRadius;
          const yOffset = relY + Math.sin(angle) * hexRadius;
          if (i === 0) hexPath.moveTo(xOffset, yOffset);
          else hexPath.lineTo(xOffset, yOffset);
        }
        hexPath.closePath();
        terrainGroups[terrainId].addPath(hexPath);
      });
      const borderColor = getComputedStyle(document.documentElement)
                             .getPropertyValue('--border-color').trim() || '#333333';
      for (const terrainId in terrainGroups) {
        offCtx.fillStyle = cellDefinitions[terrainId].color;
        offCtx.fill(terrainGroups[terrainId]);
        if (gap) {
          offCtx.strokeStyle = borderColor;
          offCtx.lineWidth = 2;
          offCtx.stroke(terrainGroups[terrainId]);
        }
      }
      chunkCache.set(chunkKey, { canvas: offscreen, minX: minX, minY: minY, width: width, height: height });
    }

    function updateSuperChunks() {
      const groupingFactor = 2;
      const tempSuper = new Map();
      chunkCache.forEach((smallChunk, key) => {
        const parts = key.split('_');
        const a = parseInt(parts[0]);
        const b = parseInt(parts[1]);
        const superKey = Math.floor(a / groupingFactor) + '_' + Math.floor(b / groupingFactor);
        if (!tempSuper.has(superKey)) {
          tempSuper.set(superKey, []);
        }
        tempSuper.get(superKey).push({ key, smallChunk });
      });
      const newSuperChunkCache = new Map();
      tempSuper.forEach((group, superKey) => {
        let groupMinX = Infinity, groupMinY = Infinity, groupMaxX = -Infinity, groupMaxY = -Infinity;
        group.forEach(item => {
          const sc = item.smallChunk;
          if (sc.minX < groupMinX) groupMinX = sc.minX;
          if (sc.minY < groupMinY) groupMinY = sc.minY;
          if (sc.minX + sc.width > groupMaxX) groupMaxX = sc.minX + sc.width;
          if (sc.minY + sc.height > groupMaxY) groupMaxY = sc.minY + sc.height;
        });
        if (!gap) {
          groupMinX -= 2;
          groupMinY -= 2;
          groupMaxX += 2;
          groupMaxY += 2;
        }
        const groupWidth = groupMaxX - groupMinX;
        const groupHeight = groupMaxY - groupMinY;
        const superCanvas = document.createElement('canvas');
        superCanvas.width = groupWidth;
        superCanvas.height = groupHeight;
        const superCtx = superCanvas.getContext('2d');
        group.forEach(item => {
          const sc = item.smallChunk;
          superCtx.drawImage(sc.canvas, sc.minX - groupMinX, sc.minY - groupMinY);
        });
        newSuperChunkCache.set(superKey, { canvas: superCanvas, minX: groupMinX, minY: groupMinY, width: groupWidth, height: groupHeight });
      });
      superChunkCache = newSuperChunkCache;
    }

    /* ---------------------------------------------------------------------------
     * Group 1: Canvas and Offset Setup Functions
     * ------------------------------------------------------------------------- */
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      recalcCenterOffsets();
      drawMap();
    }
    window.addEventListener('resize', resizeCanvas);
    function recalcCenterOffsets() {
      const bounds = getMapBounds();
      const mapCenterX = (bounds.minX + bounds.maxX) / 2;
      const mapCenterY = (bounds.minY + bounds.maxY) / 2;
      offsetX = -mapCenterX;
      offsetY = -mapCenterY;
    }
    function getMapBounds() {
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      hexMap.forEach(cell => {
        const pos = evenr_to_pixel(cell);
        if (pos.x < minX) minX = pos.x;
        if (pos.x > maxX) maxX = pos.x;
        if (pos.y < minY) minY = pos.y;
        if (pos.y > maxY) maxY = pos.y;
      });
      return { minX, maxX, minY, maxY };
    }
    function evenr_to_pixel(cell) {
      const off = cell.row % 2 === 0 ? 0.5 : 0;
      const x = hexRadius * Math.sqrt(3) * (cell.col + off);
      const y = hexRadius * (3/2) * cell.row;
      return { x, y };
    }
    function drawBorder() {
      for (let row = -1; row <= rows; row++) {
        for (let col = -1; col <= cols; col++) {
          if (row === -1 || row === rows || col === -1 || col === cols) {
            const pos = evenr_to_pixel({ col, row });
            const bgColor = getComputedStyle(document.documentElement)
                             .getPropertyValue('--bg-color').trim() || '#030a1c';
            drawHex(pos.x + canvas.width/2 + offsetX, pos.y + canvas.height/2 + offsetY, bgColor);
          }
        }
      }
    }
    function drawHex(x, y, color = '#325ddb', context = ctx) {
      context.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 3 * i + Math.PI / 6;
        const xOffset = x + Math.cos(angle) * hexRadius;
        const yOffset = y + Math.sin(angle) * hexRadius;
        context.lineTo(xOffset, yOffset);
      }
      context.closePath();
      context.fillStyle = color;
      context.fill();
      if (gap) {
        context.strokeStyle = '#333333';
        context.lineWidth = 2;
        context.stroke();
      }
    }

    /* ---------------------------------------------------------------------------
     * Group 3: Map Drawing Functions
     * ------------------------------------------------------------------------- */
    function drawMap() {
      ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBorder();
      if (mapDirty) {
        chunkCache.clear();
        chunkSize = computeChunkSize();
        const chunks = new Map();
        hexMap.forEach(cell => {
          const key = getChunkKey(cell.col, cell.row);
          if (!chunks.has(key)) {
            chunks.set(key, []);
          }
          chunks.get(key).push(cell);
        });
        chunks.forEach((cells, key) => {
          let tempMinX = Infinity, tempMinY = Infinity, tempMaxX = -Infinity, tempMaxY = -Infinity;
          cells.forEach(cell => {
            const pos = evenr_to_pixel(cell);
            tempMinX = Math.min(tempMinX, pos.x);
            tempMaxX = Math.max(tempMaxX, pos.x);
            tempMinY = Math.min(tempMinY, pos.y);
            tempMaxY = Math.max(tempMaxY, pos.y);
          });
          tempMinX -= hexRadius;
          tempMinY -= hexRadius;
          tempMaxX += hexRadius;
          tempMaxY += hexRadius;
          if (!gap) {
            tempMinX -= 2;
            tempMinY -= 2;
            tempMaxX += 2;
            tempMaxY += 2;
          }
          const screenMinX = tempMinX + canvas.width / 2 + offsetX;
          const screenMinY = tempMinY + canvas.height / 2 + offsetY;
          const screenMaxX = tempMaxX + canvas.width / 2 + offsetX;
          const screenMaxY = tempMaxY + canvas.height / 2 + offsetY;
          if (screenMaxX >= 0 && screenMinX <= canvas.width &&
              screenMaxY >= 0 && screenMinY <= canvas.height) {
            updateChunk(key, cells);
          }
        });
        updateSuperChunks();
        mapDirty = false;
      }
      chunkCache.forEach(chunk => {
        const screenX = chunk.minX + canvas.width / 2 + offsetX;
        const screenY = chunk.minY + canvas.height / 2 + offsetY;
        if (screenX + chunk.width >= 0 && screenX <= canvas.width &&
            screenY + chunk.height >= 0 && screenY <= canvas.height) {
          ctx.drawImage(chunk.canvas, screenX, screenY);
        }
      });
      hexMap.forEach(cell => {
        if (!(cell.objectId && cell.nationId)) return;
        const obj = objectDefinitions[cell.objectId - 1];
        const nat = nationDefinitions[cell.nationId - 1];
        if (!obj || !nat) return;

        const pos     = evenr_to_pixel(cell);
        const screenX = pos.x + canvas.width / 2 + offsetX;
        const screenY = pos.y + canvas.height / 2 + offsetY;

        const objPath = `assets/objects/${obj.name.toLowerCase()}.svg`;
        const natPath = `assets/flags/${nat.name.toLowerCase()}.svg`;
        let contrast = 1;

        switch(obj.name.toLowerCase()) {
          case "city":
            contrast = 1;
            break;
          case "industry":
            contrast = 0.9;
            break;
          case "village":
            contrast = 0.8;
            break;
          case "infantry":
            contrast = 0.7;
            break;
          case "ranged":
            contrast = 0.7;
            break;
          case "cavalry":
            contrast = 0.7;
            break;
          default:
            contrast = 0.7;
        }

        // pobieramy z cache'u bitmapy SVG
        const objImg = getImage(objPath);
        const natImg = getImage(natPath);

        // jeśli któryś nie załadowany — od razu wrzucamy loadImage, a compositu nie rysujemy
        if (!objImg || !natImg) {
          loadImage(objPath, loadedObj => {
            cacheImage(objPath, loadedObj);
          });
          loadImage(natPath, loadedNat => {
            cacheImage(natPath, loadedNat);
          });
          return;
        }

        // klucz do compositu
        const key  = `${obj.name}::${nat.name}`;
        const size = hexRadius*1.9;
        // wygeneruj composit tylko raz
        const comp = ensureComposite(objImg, natImg, key, 300);

        // i teraz tylko drawImage z gotowego bitmapowego canvasu
        ctx.save();                            // zapamiętaj stan
        ctx.filter = `contrast(${contrast})`;        
        ctx.drawImage(comp, screenX - size/2, screenY - size/2, size, size);
        ctx.restore(); 

      });
    }

    /* ---------------------------------------------------------------------------
     * Group 4: History Management Functions
     * ------------------------------------------------------------------------- */
    function saveHistory() {
      const state = {
        hexMap: JSON.parse(JSON.stringify(hexMap)),
        cols: cols,
        rows: rows
      };
      history.length = historyIndex + 1;
      history.push(state);
      historyIndex++;
    }
    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        const state = history[historyIndex];
        cols = state.cols;
        rows = state.rows;
        hexMap.length = 0;
        hexMap.push(...JSON.parse(JSON.stringify(state.hexMap)));
        mapDirty = true;
        drawMap();
      }
    }
    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        const state = history[historyIndex];
        cols = state.cols;
        rows = state.rows;
        hexMap.length = 0;
        hexMap.push(...JSON.parse(JSON.stringify(state.hexMap)));
        mapDirty = true;
        drawMap();
      }
    }

    /* ---------------------------------------------------------------------------
     * Group 5: Map Panning Functions
     * ------------------------------------------------------------------------- */
    function moveMap(dx, dy) {
      offsetX += dx;
      offsetY += dy;
      const bounds = getMapBounds();
      const minAllowedOffsetX = - (bounds.maxX + canvas.width / 2);
      const maxAllowedOffsetX = canvas.width / 2 - bounds.minX;
      offsetX = Math.min(Math.max(offsetX, minAllowedOffsetX), maxAllowedOffsetX);
      const minAllowedOffsetY = - (bounds.maxY + canvas.height / 2);
      const maxAllowedOffsetY = canvas.height / 2 - bounds.minY;
      offsetY = Math.min(Math.max(offsetY, minAllowedOffsetY), maxAllowedOffsetY);
      drawMap();
    }

    /* ---------------------------------------------------------------------------
     * Group 6: Animation Functions
     * ------------------------------------------------------------------------- */
    let lastTimeAnimation = performance.now();
    function animate() {
      const now = performance.now();
      const dt = (now - lastTimeAnimation) / 1000;
      lastTimeAnimation = now;
      let vx = 0, vy = 0;
      if (keysPressed['w'] || keysPressed['ArrowUp']) vy += 1;
      if (keysPressed['s'] || keysPressed['ArrowDown']) vy -= 1;
      if (keysPressed['a'] || keysPressed['ArrowLeft']) vx += 1;
      if (keysPressed['d'] || keysPressed['ArrowRight']) vx -= 1;
      if (vx !== 0 || vy !== 0) {
        const len = Math.sqrt(vx * vx + vy * vy);
        vx /= len;
        vy /= len;
        const speed = 200;
        moveMap(vx * speed * dt, vy * speed * dt);
      }
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    /* ---------------------------------------------------------------------------
     * Group 7: Cell Selection and Object Helper Functions
     * ------------------------------------------------------------------------- */
    function getCellAt(x, y) {
      for (const cell of hexMap) {
        const pos = evenr_to_pixel(cell);
        const centerX = pos.x + canvas.width / 2 + offsetX;
        const centerY = pos.y + canvas.height / 2 + offsetY;
        const dx = x - centerX;
        const dy = y - centerY;
        if (Math.sqrt(dx * dx + dy * dy) < hexRadius) {
          return cell;
        }
      }
      return null;
    }
    function isBlockedForObjects(cell) {
      const terrain = cellDefinitions[cell.id];
      return ['Water','Ocean','Mountains','High Mountains','Snowy Mountains','Volcanic  Mountains'].includes(terrain.name);
    }

    /* ---------------------------------------------------------------------------
     * Group 8: Hex Grid Calculation Helper Functions
     * ------------------------------------------------------------------------- */
    function evenr_to_cube(cell) {
      let x = cell.col - Math.floor((cell.row + (cell.row & 1)) / 2);
      let z = cell.row;
      let y = -x - z;
      return { x, y, z };
    }
    function cubeDistance(a, b) {
      return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y), Math.abs(a.z - b.z));
    }
    function getCellsInRange(center, range) {
      const centerCube = evenr_to_cube(center);
      return hexMap.filter(cell => {
        const cellCube = evenr_to_cube(cell);
        return cubeDistance(centerCube, cellCube) <= range;
      });
    }

    /* ---------------------------------------------------------------------------
     * Group 9: Cell Painting Functions
     * ------------------------------------------------------------------------- */
    function paintCell(cell) {
      if (drawMode === 'object') {
        if (selectedTool === 'eraser') {
          if (cell.objectId === 0 && cell.nationId === 0) return;
          cell.objectId = 0;
          cell.nationId = 0;
        } else if (selectedTool === 'pencil') {
          if (isBlockedForObjects(cell)) return;
          if (cell.objectId === selectedObjectId && cell.nationId === selectedNationId) return;
          cell.objectId = selectedObjectId;
          cell.nationId = selectedNationId;
          mapDirty = true;
          saveHistory();
          drawMap();
        }
        mapDirty = true;
        saveHistory();
        drawMap();
      } else {
        if (selectedTool === 'bucket') {
          if (cell.id === selectedTerrainId) return;
          const targetId = cell.id;
          const queue = [cell];
          while (queue.length) {
            const current = queue.pop();
            if (current.id === targetId) {
              current.id = selectedTerrainId;
              if (['Water','Ocean','Mountains','High Mountains','Snowy Mountains','Volcanic  Mountains'].includes(cellDefinitions[selectedTerrainId].name) && current.objectId) {
                current.objectId = 0;
                current.nationId = 0;
              }
              const neighbors = hexMap.filter(c => {
                const dcol = Math.abs(c.col - current.col);
                const drow = Math.abs(c.row - current.row);
                return dcol <= 1 && drow <= 1;
              });
              queue.push(...neighbors.filter(c => c.id === targetId));
            }
          }
          mapDirty = true;
          saveHistory();
          drawMap();
        } else if (selectedTool === 'pencil') {
          if (cell.id === selectedTerrainId) return;
          if (['Water','Ocean','Mountains','High Mountains','Snowy Mountains','Volcanic  Mountains'].includes(cellDefinitions[selectedTerrainId].name) && cell.objectId) {
            cell.objectId = 0;
            cell.nationId = 0;
          }
          cell.id = selectedTerrainId;
          mapDirty = true;
          saveHistory();
          drawMap();
        } else if (selectedTool === 'big-pencil') {
          if (cell.id === selectedTerrainId) return;
          const cellsToPaint = getCellsInRange(cell, bigBrushSize);
          const centerCube = evenr_to_cube(cell);
          cellsToPaint.forEach(c => { //big brush is blocked for objects
            const cellCube = evenr_to_cube(c);
            const distance = cubeDistance(centerCube, cellCube);
            let p = 1 - (distance / bigBrushSize) * (bigBrushRoughness / 9);
            p = Math.max(0, p);
            if (Math.random() < p) {
              if (c.id !== selectedTerrainId) {
                c.id = selectedTerrainId;
                if (['Water','Ocean','Mountains','High Mountains','Snowy Mountains','Volcanic  Mountains'].includes(cellDefinitions[selectedTerrainId].name) && c.objectId) {
                  c.objectId = 0;
                  c.nationId = 0;
                }
                markDirtyForCell(c);
              }
            }
          });
          mapDirty = true;
          saveHistory();
          drawMap();
        } else if (selectedTool === 'eraser') {
          if (cell.id === 0) return;
          cell.id = 0;
          mapDirty = true;
          saveHistory();
          drawMap();
        }
      }
    }
    function markDirtyForCell(cell) {
      const key = getChunkKey(cell.col, cell.row);
      dirtyChunks.add(key);
      mapDirty = true;
    }

    /* ---------------------------------------------------------------------------
     * Group 10: UI Update Functions
     * ------------------------------------------------------------------------- */
    function updateListVisibility() {
      const toolButtons = document.querySelectorAll('.tool-button');
      if (drawMode === 'color') {
        document.getElementById('terrainList').style.display = 'block';
        //document.getElementById('nationList').style.display = 'none';
        document.getElementById('teamList').style.display = 'none';
        document.getElementById('leftSidebarObjects').style.display = 'none';
        document.getElementById('leftSidebarCells').style.display = 'flex';
        setTool('pencil');
        toolButtons.forEach(btn => btn.classList.remove('selected'));
        const pencilBtn = document.querySelector("#leftSidebarCells .tool-button[data-tool='pencil']");
        if (pencilBtn) pencilBtn.classList.add('selected');
      } else {
        document.getElementById('terrainList').style.display = 'none';
        //document.getElementById('nationList').style.display = 'block';
        document.getElementById('teamList').style.display = 'block';
        document.getElementById('leftSidebarObjects').style.display = 'flex';
        document.getElementById('leftSidebarCells').style.display = 'none';
        setTool('pencil');
        toolButtons.forEach(btn => btn.classList.remove('selected'));
        const pencilBtn = document.querySelector("#leftSidebarObjects .tool-button[data-tool='pencil']");
        if (pencilBtn) pencilBtn.classList.add('selected');
      }
    }

    /* ---------------------------------------------------------------------------
     * DODATKOWE FUNKCJE DLA TRYBU OBIEKTOWEGO
     * ------------------------------------------------------------------------- */
    function selectObjectTool(tool, element) {
      setTool(tool);
      document.querySelectorAll('#leftSidebarObjects .tool-button').forEach(btn => btn.classList.remove('selected'));
      element.classList.add('selected');
    }
    document.querySelectorAll('#leftSidebarObjects .tool-button').forEach(button => {
      button.addEventListener('click', function() {
        const tool = button.dataset.tool;
        // Tylko narzędzia: pencil, move, eraser są dostępne
        if (tool === 'pencil' || tool === 'move' || tool === 'eraser') {
          selectObjectTool(tool, button);
          if (tool === 'eraser') {
            selectedNationId = 0;
          } else {
            if (selectedNationId === 0) {
              selectedNationId = nationDefinitions[0].id;
            }
          }
        }
      });
    });
    function highlightCell(cell) {
      if (!cell) return;
      if (isBlockedForObjects(cell)) return;
      if (!selectedObjectId || !selectedNationId) return;

      const obj  = objectDefinitions[selectedObjectId - 1];
      const nat  = nationDefinitions[selectedNationId - 1];
      if (!obj || !nat) return;

      // 1) Oblicz pozycję na ekranie
      const pos     = evenr_to_pixel(cell);
      const screenX = pos.x + canvas.width  / 2 + offsetX;
      const screenY = pos.y + canvas.height / 2 + offsetY;

      // 2) Ścieżki do plików SVG
      const objPath = `assets/objects/${obj.name.toLowerCase()}.svg`;
      const natPath = `assets/flags/${nat.name.toLowerCase()}.svg`;

      // 3) Pobrać obie bitmapy z cache albo asynchronicznie
      const objImg = getImage(objPath);
      const natImg = getImage(natPath);

      // Jeśli nie ma w cache, załaduj je i po załadowaniu przerysuj
      if (!objImg || !natImg) {
        // załaduj obiekt
        loadImage(objPath, loadedObj => {
          // załaduj flagę
          loadImage(natPath, loadedNat => {
            // po załadowaniu obu, zapisz w cache i wywołaj ponownie
            window.cacheImage(objPath,  loadedObj);
            window.cacheImage(natPath,  loadedNat);
          });
        });
        return;
      }

      // 4) Off-screen canvas do maskowania
      const size = hexRadius*1.9;
      const off = document.createElement('canvas');
      off.width  = size;
      off.height = size;
      const offCtx = off.getContext('2d');

      // 5) Narysuj kształt obiektu jako maskę (white silhouette)
      offCtx.clearRect(0, 0, size, size);
      offCtx.drawImage(objImg, 0, 0, size, size);

      // 6) Ustaw compositing: zachowaj tylko obszar, który pokrywa się z kształtem
      offCtx.globalCompositeOperation = 'source-in';

      // 7) Narysuj flagę w tym obszarze
      offCtx.drawImage(natImg, 0, 0, size, size);

      // 8) Przywróć domyślny compositing
      offCtx.globalCompositeOperation = 'source-over';

      // 9) Nałóż całość na główny context (z połprzezroczystością)
      ctx.save();
      ctx.globalAlpha = 0.5;
      ctx.filter = 'contrast(0.0)';        
      ctx.drawImage(off, screenX - size/2, screenY - size/2, size, size);
      ctx.restore();
    }



    

    // Globalny cache obrazków (nie powoduje błędu przy wielokrotnym użyciu)
    window.imageCache = window.imageCache || {};

    // Funkcja cacheImage
    if (!window.cacheImage) {
      window.cacheImage = function (url, img) {
        window.imageCache[url] = img;
      };
    }

    // Funkcja getImage
    if (!window.getImage) {
      window.getImage = function (url) {
        return window.imageCache[url] || null;
      };
    }














    



    canvas.addEventListener('mousemove', function(e) {
      if (drawMode === 'object' && !isPainting) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const cell = getCellAt(mouseX, mouseY);
        drawMap();
        if (cell) {
          highlightCell(cell);
        }
      }
    });

    /* ---------------------------------------------------------------------------
     * Group 11: Image Loading Functions
     * ------------------------------------------------------------------------- */
    // Gdzieś globalnie:
    const compositeCache = {};        // będzie trzymać już skomponowane canvasy
    const reuseCanvas = document.createElement('canvas');
    const reuseCtx    = reuseCanvas.getContext('2d');

    // Funkcja do wygenerowania compositu raz na dany obj+flag
    function ensureComposite(objImg, natImg, key, size) {
      if (compositeCache[key]) return compositeCache[key];

      // ustawiamy reuseCanvas o odpowiednim rozmiarze
      reuseCanvas.width  = size;
      reuseCanvas.height = size;
      reuseCtx.clearRect(0, 0, size, size);

      // 1) maska obiektu
      reuseCtx.drawImage(objImg, 0, 0, size, size);
      // 2) compositing
      reuseCtx.globalCompositeOperation = 'source-in';
      reuseCtx.drawImage(natImg, 0, 0, size, size);
      // 3) przywracamy
      reuseCtx.globalCompositeOperation = 'source-over';

      // kopiujemy do osobnego canvasu (żeby reuseCtx.clearRect nie skasowało tego)
      const finalCanvas = document.createElement('canvas');
      finalCanvas.width  = size;
      finalCanvas.height = size;
      finalCanvas.getContext('2d').drawImage(reuseCanvas, 0, 0);

      compositeCache[key] = finalCanvas;
      return finalCanvas;
    }


    
    function loadImage(imagePath, callback) {
      if (imageCache[imagePath]) {
        callback(imageCache[imagePath]);
        return;
      }
      fetch(imagePath)
        .then(response => response.text())
        .then(data => {
          const svgBlob = new Blob([data], { type: 'image/svg+xml;charset=utf-8' });
          const url = URL.createObjectURL(svgBlob);
          const image = new Image();
          image.onload = function() {
            imageCache[imagePath] = image;
            callback(image);
            URL.revokeObjectURL(url);
          };
          image.src = url;
        })
        .catch(error => console.error('Error loading image:', error));
    }
    function getImage(imagePath) {
      return imageCache[imagePath];
    }
    function getImageData(canvas) {
      return canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height).data;
    }

    /* ---------------------------------------------------------------------------
     * Group 12: Map Initialization and Resizing Functions
     * ------------------------------------------------------------------------- */
    // Funkcja generująca proceduralną mapę wysokości metodą midpoint displacement
    function generateProceduralHeightMap(size, roughness) {
      let map = Array(size).fill(0).map(() => Array(size).fill(0));
      // Inicjujemy narożniki
      map[0][0] = Math.random();
      map[0][size - 1] = Math.random();
      map[size - 1][0] = Math.random();
      map[size - 1][size - 1] = Math.random();
      
      function midpointDisplacement(plot) {
        let subPlot = plot / 2;
        if (subPlot < 1) return;
        
        for (let i = subPlot; i < size; i += subPlot) {
          for (let j = subPlot; j < size; j += subPlot) {
            let x = i - (subPlot / 2);
            let y = j - (subPlot / 2);
            let avg = (map[i - subPlot][j - subPlot] + map[i][j - subPlot] + map[i - subPlot][j] + map[i][j]) / 4;
            map[x][y] = avg + (Math.random() - 0.5) * roughness;
            map[x][y] = Math.max(0, Math.min(map[x][y], 1));
          }
        }
        midpointDisplacement(subPlot);
      }
      midpointDisplacement(size);
      return map;
    }

    function initHexMap() {
      hexMap.length = 0;
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          hexMap.push({ col, row, id: 0, objectId: 0, nationId: 0 });
        }
      }
      recalcCenterOffsets();
      chunkSize = computeChunkSize();
      mapDirty = true;
      drawMap();
      saveHistory();
    }
    initHexMap();

    // updateHexSize – zmiana hexRadius i ustawienie gap w zależności od rozmiaru
    let isZooming = false;
    let zoomDebounceTimer = null;
    function updateHexSize(newSize) {
      hexRadius = newSize;
      hexWidth = Math.sqrt(3) * hexRadius;
      hexHeight = 2 * hexRadius;
      gap = (newSize > 10);
      isZooming = true;
      recalcCenterOffsets();
      mapDirty = true;
      drawMap();
      clearTimeout(zoomDebounceTimer);
      zoomDebounceTimer = setTimeout(() => {
        isZooming = false;
        mapDirty = true;
        drawMap();
      }, 200);
    }
    hexSizeInput.addEventListener('input', (event) => {
      const newSize = parseInt(event.target.value);
      if (zoomDebounceTimer) clearTimeout(zoomDebounceTimer);
      zoomDebounceTimer = setTimeout(() => {
        updateHexSize(newSize);
        zoomDebounceTimer = null;
      }, 50);
    });
    zoomInButton.addEventListener('click', () => {
      let current = parseInt(hexSizeInput.value);
      if (current < parseInt(hexSizeInput.max)) {
        current++;
        hexSizeInput.value = current;
        zoomLevel *= 1.2;
        updateHexSize(current);
      }
    });
    zoomOutButton.addEventListener('click', () => {
      let current = parseInt(hexSizeInput.value);
      if (current > parseInt(hexSizeInput.min)) {
        current--;
        hexSizeInput.value = current;
        zoomLevel /= 1.2;
        updateHexSize(current);
      }
    });

    function isMapPainted() {
      return hexMap.some(cell => cell.id !== 0 || cell.objectId !== 0 || cell.nationId !== 0);
    }
    function resizeMap(newCols, newRows) {
      const newHexMap = [];
      const scaleX = (cols - 1) / (newCols - 1);
      const scaleY = (rows - 1) / (newRows - 1);
      for (let newRow = 0; newRow < newRows; newRow++) {
        for (let newCol = 0; newCol < newCols; newCol++) {
          const oldCol = Math.round(newCol * scaleX);
          const oldRow = Math.round(newRow * scaleY);
          const clampedOldCol = Math.min(oldCol, cols - 1);
          const clampedOldRow = Math.min(oldRow, rows - 1);
          const oldCell = hexMap.find(cell => cell.col === clampedOldCol && cell.row === clampedOldRow);
          if (oldCell) {
            newHexMap.push({ col: newCol, row: newRow, id: oldCell.id, objectId: oldCell.objectId, nationId: oldCell.nationId });
          } else {
            newHexMap.push({ col: newCol, row: newRow, id: 0, objectId: 0, nationId: 0 });
          }
        }
      }
      cols = newCols;
      rows = newRows;
      hexMap.length = 0;
      hexMap.push(...newHexMap);
      mapDirty = true;
      recalcCenterOffsets();
      drawMap();
      saveHistory();
    }

    /* =================== EVENT LISTENERS AND UI HANDLERS =================== */
    let isMousePanning = false;
    canvas.addEventListener('mousedown', (event) => {
      if (event.button === 0 && selectedTool === 'move') {
        isMousePanning = true;
        setCursor('move2');
      }
    });
    canvas.addEventListener('mouseup', (event) => {
      if (event.button === 0 && selectedTool === 'move') {
        isMousePanning = false;
        setCursor(selectedTool);
        mapDirty = true;
        drawMap();
      }
    });
    let previousTool = null;
    let isMiddleMousePanning = false;
    canvas.addEventListener('mousedown', (event) => {
      if (event.button === 1) {
        event.preventDefault();
        previousTool = selectedTool;
        selectedTool = 'move';
        isMiddleMousePanning = true;
        setCursor('move2');
      }
    });
    canvas.addEventListener('mouseup', (event) => {
      if (event.button === 1) {
        event.preventDefault();
        isMiddleMousePanning = false;
        selectedTool = previousTool || 'move';
        setCursor(selectedTool);
        mapDirty = true;
        drawMap();
      }
    });
    canvas.addEventListener('mousemove', (event) => {
      if ((selectedTool === 'move' && isMousePanning) || isMiddleMousePanning) {
        moveMap(event.movementX, event.movementY);
      }
    });

    let isPainting = false;
    canvas.addEventListener('mousedown', (event) => {
      if (event.button !== 0) return;
      if (selectedTool !== 'move') {
        isPainting = true;
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        const cell = getCellAt(mouseX, mouseY);
        if (cell) paintCell(cell);
      }
    });
    canvas.addEventListener('mouseup', () => { isPainting = false; });
    canvas.addEventListener('mouseleave', () => { isPainting = false; });
    canvas.addEventListener('mousemove', (event) => {
      if (isPainting && selectedTool !== 'move') {
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        const cell = getCellAt(mouseX, mouseY);
        if (cell) paintCell(cell);
      }
    });

    resetButton.addEventListener('click', initHexMap);
    resizeButton.addEventListener('click', () => {
      let newCols = parseInt(colsInput.value);
      let newRows = parseInt(rowsInput.value);
      if (newCols < 5) newCols = 5;
      if (newRows < 5) newRows = 5;
      if (newCols > 200) newCols = 200;
      if (newRows > 150) newRows = 150;
      if (isMapPainted()) {
        resizeMap(newCols, newRows);
      } else {
        cols = newCols;
        rows = newRows;
        initHexMap();
      }
    });

    document.addEventListener('keydown', (event) => {
      const tag = event.target.tagName.toLowerCase();
      if ((tag === 'input' || tag === 'textarea') && !(event.ctrlKey && (event.key === 'z' || event.key === 'y'))) {
        return;
      }
      if (['w','a','s','d','ArrowUp','ArrowLeft','ArrowDown','ArrowRight'].includes(event.key)) {
        keysPressed[event.key] = true;
        event.preventDefault();
      }
      if (event.key === 'p') {
        const pencilBtn = document.querySelector(".tool-button[data-tool='pencil']");
        if (pencilBtn && getComputedStyle(pencilBtn).display === 'block') {
          setTool('pencil');
          event.preventDefault();
        }
      }
      if (event.key === 'b') {
        const bigPencilBtn = document.querySelector(".tool-button[data-tool='big-pencil']");
        if (bigPencilBtn && getComputedStyle(bigPencilBtn).display === 'block') {
          setTool('big-pencil');
          document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('selected'));
          bigPencilBtn.classList.add('selected');
          event.preventDefault();
        }
      }
      if (event.key === 'm') {
        const moveBtn = document.querySelector(".tool-button[data-tool='move']");
        if (moveBtn && getComputedStyle(moveBtn).display === 'block') {
          setTool('move');
          document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('selected'));
          moveBtn.classList.add('selected');
          event.preventDefault();
        }
      }
      if (event.key === 'e') {
        const eraserBtn = document.querySelector(".tool-button[data-tool='eraser']");
        if (eraserBtn && getComputedStyle(eraserBtn).display === 'block') {
          setTool('eraser');
          document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('selected'));
          eraserBtn.classList.add('selected');
          event.preventDefault();
        }
      }
      if (event.key === 'f') {
        const bucketBtn = document.querySelector(".tool-button[data-tool='bucket']");
        if (bucketBtn && getComputedStyle(bucketBtn).display === 'block') {
          setTool('bucket');
          document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('selected'));
          bucketBtn.classList.add('selected');
          event.preventDefault();
        }
      }
      if (event.key === '-' || (event.ctrlKey && event.key === '-')) {
        zoomOutButton.click();
        event.preventDefault();
      }
      if (event.key === '+' || (event.ctrlKey && event.key === '+')) {
        zoomInButton.click();
        event.preventDefault();
      }
      if (event.ctrlKey && event.key === 'z') {
        event.preventDefault();
        undo();
      }
      if (event.ctrlKey && event.key === 'y') {
        event.preventDefault();
        redo();
      }
    });
    document.addEventListener('keyup', (event) => {
      const tag = event.target.tagName.toLowerCase();
      if ((tag === 'input' || tag === 'textarea') && !(event.ctrlKey && (event.key === 'z' || event.key === 'y'))) {
        return;
      }
      if (['w','a','s','d','ArrowUp','ArrowLeft','ArrowDown','ArrowRight'].includes(event.key)) {
        keysPressed[event.key] = false;
        event.preventDefault();
      }
    });
    canvas.addEventListener('wheel', (event) => {
      if (event.ctrlKey) {
        if (event.deltaY > 0) {
          zoomOutButton.click();
        } else if (event.deltaY < 0) {
          zoomInButton.click();
        }
        event.preventDefault();
      }
    });

    const toolButtons = document.querySelectorAll('.tool-button');
    toolButtons.forEach(button => {
      button.addEventListener('click', () => {
        if (drawMode === 'color') {
          setTool(button.dataset.tool);
          toolButtons.forEach(btn => btn.classList.remove('selected'));
          button.classList.add('selected');
        }
      });
    });
    switchModeButton.addEventListener('click', () => {
      drawMode = drawMode === 'color' ? 'object' : 'color';
      switchModeButton.textContent = `Mode: ${drawMode === 'color' ? 'Colors' : 'Objects'}`;
      updateListVisibility();
    });
    document.getElementById('undoButton').addEventListener('click', undo);
    document.getElementById('redoButton').addEventListener('click', redo);

    const terrainList = document.getElementById('terrainList');
    //const nationList = document.getElementById('nationList');
    cellDefinitions.forEach((terrain, index) => {
      const tile = document.createElement('div');
      tile.classList.add('tile');
      tile.dataset.terrainId = index;
      const colorBox = document.createElement('div');
      colorBox.classList.add('tile-color');
      colorBox.style.backgroundColor = terrain.color;
      const label = document.createElement('span');
      label.textContent = terrain.name;
      tile.appendChild(colorBox);
      tile.appendChild(label);
      terrainList.appendChild(tile);
      tile.addEventListener('click', () => {
        selectedTerrainId = parseInt(tile.dataset.terrainId);
        document.querySelectorAll('#terrainList .tile').forEach(t => t.classList.remove('selected'));
        tile.classList.add('selected');
      });
      if (index === selectedTerrainId) {
        tile.classList.add('selected');
      }
    });
    /*nationDefinitions.forEach((nation, index) => {
      const tile = document.createElement('div');
      tile.classList.add('tile');
      tile.dataset.nationId = nation.id;
      const flagContainer = document.createElement('div');
      flagContainer.classList.add('tile-flag');
      const flagImage = document.createElement('img');
      const flagPath = './assets/flags/' + nation.name + '.svg';
      flagImage.src = flagPath;
      flagImage.alt = `${nation.name} flag`;
      flagContainer.appendChild(flagImage);
      const label = document.createElement('span');
      label.textContent = nation.name;
      tile.appendChild(flagContainer);
      tile.appendChild(label);
      nationList.appendChild(tile);
      tile.addEventListener('click', () => {
        selectedNationId = parseInt(tile.dataset.nationId);
        document.querySelectorAll('#nationList .tile').forEach(t => t.classList.remove('selected'));
        tile.classList.add('selected');
      });
      if (index === 0) {
        tile.classList.add('selected');
        selectedNationId = nation.id;
      }
    });
    */












    
























































    // Maksymalna liczba drużyn i krajów
const maxTeams = 5;
const maxCountriesPerTeam = 5;

// Domyślnie tworzymy dwie drużyny
let teams = [{ countries: [] }, { countries: [] }];

const teamsContainer = document.getElementById('teamList');


// ---------------------------------------------
// Funkcja wyświetlająca listę krajów (kafelki)
// ---------------------------------------------

// ---------------------------------------------
// Funkcja wyświetlająca drużyny oraz panel dodawania krajów
// ---------------------------------------------
function renderTeams() {
  teamsContainer.innerHTML = '';
  
  teams.forEach((team, teamIndex) => {
    const teamDiv = document.createElement('div');
    teamDiv.classList.add('team');
    teamDiv.innerHTML = `<h3>Drużyna ${teamIndex + 1}</h3>`;
    
    // Lista krajów w drużynie
    const list = document.createElement('ul');
    list.classList.add('team-list');
    list.dataset.teamIndex = teamIndex;
    
    // Wyświetlamy kraje w drużynie
    team.countries.forEach((nation, countryIndex) => {
      const li = document.createElement('li');
      li.dataset.nationId = nation.id;

      const flagContainer = document.createElement('div');
      flagContainer.classList.add('tile-flag');
      const flagImage = document.createElement('img');
      const flagPath = `assets/flags/${nat.name.toLowerCase()}.svg`;
      flagImage.src = flagPath;
      flagImage.alt = `${nation.name} flag`;
      flagContainer.appendChild(flagImage);
      const label = document.createElement('span');
      label.textContent = nation.name;


      
      const liObjects = document.createElement('li');
      liObjects.classList.add('objects');
      liObjects.style.display = "none";
      objectDefinitions.forEach((object, index) => {
        const iconContainer = document.createElement('div');
        iconContainer.dataset.objectId = object.id;
        iconContainer.classList.add('tile-flag');
        const iconImage = document.createElement('img');




        iconImage.alt = `${object.name} icon`;
        iconContainer.appendChild(iconImage);
        const label = document.createElement('span');
        label.textContent = object.name;
        liObjects.appendChild(iconContainer);

        iconContainer.addEventListener('click', () => {
          selectedNationId = parseInt(li.dataset.nationId);
          selectedObjectId = parseInt(iconContainer.dataset.objectId);
          document.querySelectorAll('#nationList .tile').forEach(t => t.classList.remove('selected'));
          iconContainer.classList.add('selected');
        });
      });
      // Przycisk usunięcia kraju z drużyny
      const removeBtn = document.createElement('button');
      removeBtn.textContent = '❌';
      removeBtn.addEventListener('click', () => {
        team.countries.splice(countryIndex, 1);
        renderTeams();
      });

      const showBtn = document.createElement('button');
      showBtn.textContent = '>';
      showBtn.addEventListener('click', () => {
        liObjects.style.display = (liObjects.style.display === 'none' || liObjects.style.display === '') ? 'flex' : 'none';
      });
      
      li.appendChild(flagContainer);
      li.appendChild(label);
      li.appendChild(showBtn);
      li.appendChild(removeBtn);
      li.appendChild(liObjects);
      list.appendChild(li);
    });
    
    teamDiv.appendChild(list);
    
    // ---------------------------------------------
    // Panel dodawania kraju z użyciem listy rozwijanej
    // ---------------------------------------------
    const addCountryContainer = document.createElement('div');
    addCountryContainer.classList.add('add-country-container');
    
    const countrySelect = document.createElement('select');
    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = '-- Wybierz kraj --';
    countrySelect.appendChild(defaultOption);
    
    nationDefinitions.forEach(nation => {
      const option = document.createElement('option');
      option.value = nation.id;
      option.textContent = nation.name;
      // Jeżeli kraj już jest w drużynie, opcja zostanie wyłączona
      if (team.countries.some(n => n.id === nation.id)) {
        option.disabled = true;
      }
      countrySelect.appendChild(option);
    });
    
    const addCountryBtn = document.createElement('button');
    addCountryBtn.textContent = 'Dodaj kraj';
    addCountryBtn.addEventListener('click', () => {
      const selectedValue = countrySelect.value;
      if (selectedValue && team.countries.length < maxCountriesPerTeam) {
        const nationToAdd = nationDefinitions.find(n => n.id == selectedValue);
        if (nationToAdd && !team.countries.some(n => n.id === nationToAdd.id)) {
          team.countries.push(nationToAdd);
          renderTeams();
        }
      }
    });
    
    addCountryContainer.appendChild(countrySelect);
    addCountryContainer.appendChild(addCountryBtn);
    teamDiv.appendChild(addCountryContainer);
    
    teamsContainer.appendChild(teamDiv);
  });
  
  // ---------------------------------------------
  // Przycisk dodawania nowej drużyny (na końcu listy drużyn)
  // ---------------------------------------------
  if (teams.length < maxTeams) {
    const addTeamDiv = document.createElement('div');
    addTeamDiv.classList.add('add-team-container');
    const addTeamButton = document.createElement('button');
    addTeamButton.textContent = 'Dodaj Drużynę';
    addTeamButton.addEventListener('click', () => {
      teams.push({ countries: [] });
      renderTeams();
    });
    addTeamDiv.appendChild(addTeamButton);
    teamsContainer.appendChild(addTeamDiv);
  }
}

// Inicjalizacja: najpierw wyświetlamy listę krajów, potem drużyny
renderTeams();




































    exportButton.addEventListener('click', () => {
      const titleVal = mapTitleInput.value;
      const descVal = mapDescriptionInput.value;
      if (!/^[A-Za-z0-9-]{5,30}$/.test(titleVal)) {
        alert("Title must be 5-30 characters long and contain only letters, numbers, and hyphen.");
        return;
      }
      if (!/^[A-Za-z0-9-\s]{5,100}$/.test(descVal)) {
          alert("Description must be 5-100 characters long and contain only letters, numbers, hyphen, and spaces.");
          return;
      }
      title = titleVal || title;
      description = descVal || description;
      const data = {
        title,
        description,
        cols,
        rows,
        cellDefinitions,
        nationDefinitions,
        objectDefinitions,
        cells: hexMap
      };
      const dataStr = JSON.stringify(data, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = title + '.json';
      a.click();
      URL.revokeObjectURL(url);
    });
    importButton.addEventListener('click', () => {
      fileInput.click();
    });
    fileInput.addEventListener('change', event => {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = e => {
          const json = JSON.parse(e.target.result);
          cols = json.cols || cols;
          rows = json.rows || rows;
          mapTitleInput.value = json.title || "";
          mapDescriptionInput.value = json.description || "";
          hexMap.length = 0;
          json.cells.forEach(cell => {
            if (cell.col === undefined) cell.col = 0;
            if (cell.row === undefined) cell.row = 0;
            if (cell.id === undefined) cell.id = 0;
            if (cell.objectId === undefined) cell.objectId = 0;
            if (cell.nationId === undefined) cell.nationId = 0;
            hexMap.push(cell);
          });
          recalcCenterOffsets();
          mapDirty = true;
          drawMap();
          saveHistory();
        };
        reader.readAsText(file);
      }
    });

    /* ================= PROCEDURAL PERLIN/IMG HEX MAP GENERATOR ================= */

    // ---------------------------
    // FUNKCJE POMOCNICZE
    // ---------------------------

    // Generator seedowalnych liczb pseudolosowych (z wykorzystaniem domknięcia)
    function createSeedablePRNG(seed) {
      let _seed = seed % 233280;
      function next() {
        _seed = (_seed * 9301 + 49297) % 233280;
        return _seed / 233280;
      }
      function nextInt(min, max) {
        return Math.floor(next() * (max - min + 1)) + min;
      }
      return { next, nextInt };
    }

    // Losowa wartość zmiennoprzecinkowa wokół podanej bazy
    function randomizeDecimal(base, range = 0.5) {
      return base + (Math.random() * range - range / 2);
    }

    // Iloczyn skalarny dwóch wektorów (używany przy Perlin Noise)
    function dotProduct(grad, dist) {
      return grad[0] * dist[0] + grad[1] * dist[1];
    }

    // Liniowa interpolacja między a i b przy współczynniku t
    function lerp(a, b, t) {
      return a + t * (b - a);
    }

    // Funkcja easeInOutQuad – łagodne przejście
    function fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
    }


    // ---------------------------
    // GENERACJA MAPY PROCEDURALNEJ (PERLIN NOISE)
    // ---------------------------

    /**
     * Funkcja generująca mapę opartą na Perlin Noise.
     * @param {number} width - liczba kolumn mapy
     * @param {number} height - liczba wierszy mapy
     * @param {number} persistence - wpływ kolejnych oktaw
     * @param {number} octaves - liczba oktaw
     * @param {number} wavelengthValue - początkowa długość fali
     * @param {object} prng - generator liczb pseudolosowych (wynik createSeedablePRNG)
     * @returns {Array} dwuwymiarowa tablica wartości szumu
     */
     function perlinNoise(width, height, persistence, octaves, wavelengthValue, prng) {
      const offsetX = parseInt(Math.random() * 500); // losowe przesunięcie X
      const offsetZ = parseInt(Math.random() * 500); // losowe przesunięcie Z
      const myAmplitude = 1;
      const factor = 254; // skalowanie do zakresu 0-254

      // Tworzenie gradientów
      const gradients = new Array(width + 1);
      for (let i = 0; i <= width; i++) {
          gradients[i] = new Array(height + 1);
          for (let j = 0; j <= height; j++) {
              gradients[i][j] = [prng.next() * 2 - 1, prng.next() * 2 - 1];
          }
      }

      const noise = new Array(width).fill(null).map(() => new Array(height).fill(0));

      // Generowanie wartości Perlin Noise
      for (let x = 0; x < width; x++) {
          for (let y = 0; y < height; y++) {
              let value = 0;
              let k = x + offsetX;
              let j = y + offsetZ;
              let wavelength = wavelengthValue;
              let amplitude = myAmplitude;

              for (let o = 0; o < octaves; o++) {
                  const x0 = Math.floor(k / wavelength);
                  const x1 = x0 + 1;
                  const y0 = Math.floor(j / wavelength);
                  const y1 = y0 + 1;

                  const dot00 = dotProduct(gradients[x0 % width][y0 % height], [k / wavelength - x0, j / wavelength - y0]);
                  const dot01 = dotProduct(gradients[x0 % width][y1 % height], [k / wavelength - x0, j / wavelength - y1]);
                  const dot10 = dotProduct(gradients[x1 % width][y0 % height], [k / wavelength - x1, j / wavelength - y0]);
                  const dot11 = dotProduct(gradients[x1 % width][y1 % height], [k / wavelength - x1, j / wavelength - y1]);

                  const tx = fade(k / wavelength - x0);
                  const ty = fade(j / wavelength - y0);
                  const nx0 = lerp(dot00, dot10, tx);
                  const nx1 = lerp(dot01, dot11, tx);
                  const nxy = lerp(nx0, nx1, ty);

                  value += nxy * amplitude;
                  wavelength /= 2;
                  amplitude *= persistence - wavelength/800;
              }

              // Użycie globalnych zmiennych myPeaks oraz myExponent (ustalanych przed wywołaniem funkcji proceduralnej)
              noise[x][y] = Math.max(0, Math.min(254, Math.floor(Math.pow((value + 1) / 2 + myPeaks, myExponent) * factor)));
          }
      }

      return noise;
  }

    /**
     * Klasyfikacja terenu na podstawie wartości szumu z Perlin Noise.
     * @param {number} noiseValue
     * @returns {number} identyfikator terenu
     */
    function classifyPerlinTerrain(noiseValue) {
      if (noiseValue < 25) return 0; // Ocean
      if (noiseValue < 62) return 1; // Woda
      if (noiseValue < 73) return 4; // Wydmy
      if (noiseValue < 100) return 8;
      if (noiseValue < 130) return Math.random() < 0.99 ? 8 : 7;
      if (noiseValue < 157) return Math.random() < 0.99 ? 7 : 8;
      if (noiseValue < 198) return Math.random() < 0.99 ? 6 : 7;
      if (noiseValue < 208) return Math.random() < 0.40 ? 9 : 6;
      if (noiseValue < 227) return 11;
      if (noiseValue < 245) return 5;
      if (noiseValue < 251) return 15;
      if (noiseValue < 252) return 5;
      if (noiseValue < 253) return 15;
      if (noiseValue < 254) return Math.random() < 0.40 ? 15 : 16;
      return 16;
    }

    /**
     * Proceduralne generowanie mapy heksagonalnej na podstawie Perlin Noise.
     * Używa globalnych zmiennych: cols, rows, hexMap, myPeaks, myExponent, mapDirty, saveHistory, drawMap.
     */
    function proceduralPerlinHexMap() {
      persistence = randomizeDecimal(0.55);
      octaves = 5.5; 
      wavelength = 125 + randomizeDecimal(Math.max(cols, rows) / 7, 20);
      myPeaks = randomizeDecimal(0.15, 0.1);
      myExponent = randomizeDecimal(3.65);
      seedValue = 61403935 + Math.floor(Math.random() * 1000);

      console.log(`Generowanie mapy z parametrami:
        Persistence: ${persistence.toFixed(2)}
        Octaves: ${octaves}
        Wavelength: ${wavelength.toFixed(2)}
        Peaks: ${myPeaks.toFixed(2)}
        Exponent: ${myExponent.toFixed(2)}
        Seed: ${seedValue}
      `);

      const prng = createSeedablePRNG(seedValue);
      const noiseMap = perlinNoise(cols, rows, persistence, octaves, wavelength, prng);

      hexMap.forEach(cell => {
        let noiseValue = noiseMap[cell.col][cell.row];
        const perlinResult = classifyPerlinTerrain(noiseValue);
        const perlinIndex = cellDefinitions.findIndex(def => def.id === perlinResult);
        cell.id = perlinIndex;
        cell.objectId = 0;
        cell.nationId = 0;
      });

      mapDirty = true;
      saveHistory();
      drawMap();
    }


    // ---------------------------
    // EXPORT OBRAZU CANVAS Z KOORDYNATAMI HEXÓW
    // ---------------------------

    function exportCanvasWithHexCoords() {
      // create a temporary canvas to draw the current map + labels
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      const tempCtx = tempCanvas.getContext('2d');
      
      // draw the existing map onto it
      tempCtx.drawImage(canvas, 0, 0);
      
      // configure text style (adjust font size if needed)
      const fontSize = Math.max(11, Math.floor(hexRadius / 3));
      tempCtx.font = `${fontSize}px Arial`;
      tempCtx.fillStyle = '#000000';
      tempCtx.textAlign = 'center';
      tempCtx.textBaseline = 'middle';
      tempCtx.lineWidth = 0;
      
      // overlay each hex's (col,row) at its center
      hexMap.forEach(cell => {
        const pos = evenr_to_pixel(cell);
        const x = pos.x + canvas.width / 2 + offsetX;
        const y = pos.y + canvas.height / 2 + offsetY;
        const label = `${cell.col},${cell.row}`;
        // optional: stroke for readability
        tempCtx.fillText(label, x, y);
      });
      
      // trigger download
      const dataURL = tempCanvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = dataURL;
      a.download = `${mapTitleInput.value || 'map'}_with_coords.png`;
      a.click();
    }





    // ---------------------------
    // PODPIĘCIE PRZYCISKÓW (EVENT LISTENERS)
    // ---------------------------

    // Przycisk generujący proceduralnie mapę na podstawie Perlin Noise
    document.getElementById('aiGenerateButton').addEventListener('click', proceduralPerlinHexMap);
    document.getElementById('exportImg').addEventListener('click', exportCanvasWithHexCoords);


    /* ===================================================================== */
    updateListVisibility();
    resizeCanvas();
    mapDirty = true;
    drawMap();
  </script>
</body>
</html>