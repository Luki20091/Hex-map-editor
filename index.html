<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hex Map Editor - BETA</title>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            display: flex;
            overflow: hidden;
        }
        canvas {
            display: block;
            background-color: #333333;
            cursor: pointer;
        }
        #controls {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            width: 200px;
            overflow-y: auto;
            max-height: 100vh;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.2);
        }
        .tile {
            display: flex;
            align-items: center;
            margin: 5px 0;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: ease-in-out background 0.2s;
        }
        .tile:hover {
            background: rgba(0, 0, 0, 0.1);
        }
        .tile.selected {
            background: rgba(0, 123, 255, 0.2);
        }
        .tile-color {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            margin-right: 10px;
        }
        button {
            display: block;
            margin: 10px 0;
            padding: 5px 10px;
            border: none;
            background: #007BFF;
            color: #fff;
            cursor: pointer;
            border-radius: 4px;
        }
        button:hover {
            background: #0056b3;
        }
        .tool-button {
            margin: 5px 0;
            padding: 10px;
            border: none;
            background: #007BFF;
            color: #fff;
            cursor: pointer;
            border-radius: 4px;
            display: block;
            font-size: 20px;
            text-align: center;
        }
        .tool-button.selected {
            background: #0056b3;
        }
    </style>
</head>
<body>
    <canvas id="hexCanvas"></canvas>
    <div id="controls">
        <div id="terrainList"></div>
        <button class="tool-button selected" data-tool="pencil"><i class="fas fa-pencil-alt"></i></button>
        <button class="tool-button" data-tool="big-pencil"><i class="fas fa-pencil-ruler"></i></button>
        <button class="tool-button" data-tool="bucket"><i class="fas fa-tint"></i></button>
        <button id="exportButton">Export to JSON</button>
        <button id="importButton">Import from JSON</button>
        <button id="undoButton">Undo</button>
        <button id="redoButton">Redo</button>
        <input type="file" id="fileInput" style="display:none;">
    </div>
    <script>
        const canvas = document.getElementById("hexCanvas");
        const ctx = canvas.getContext("2d");
        const exportButton = document.getElementById("exportButton");
        const importButton = document.getElementById("importButton");
        const fileInput = document.getElementById("fileInput");
        const terrainList = document.getElementById("terrainList");
        const undoButton = document.getElementById("undoButton");
        const redoButton = document.getElementById("redoButton");

        const hexRadius = 30;
        const hexHeight = Math.sqrt(3) * hexRadius;
        const hexWidth = 2 * hexRadius;
        const hexVerticalSpacing = hexHeight;
        const cols = 25;
        const rows = 13;
        const hexMap = [];
        let selectedColor = "#228B22"; 
        let isPainting = false;
        let selectedTool = "pencil";
        let history = [];
        let historyIndex = -1;

        canvas.width = cols * hexWidth * 0.75 + hexRadius;
        canvas.height = rows * hexVerticalSpacing + hexHeight / 2;

        const terrains = [
            { name: "Mountains", color: "#8B4513" },
            { name: "Water", color: "#1E90FF" },
            { name: "Plains", color: "#228B22" },
            { name: "Desert", color: "#DAA520" },
            { name: "Forest", color: "#006400" }
        ];

        terrains.forEach(terrain => {
            const tile = document.createElement("div");
            tile.classList.add("tile");
            tile.dataset.color = terrain.color;

            const colorBox = document.createElement("div");
            colorBox.classList.add("tile-color");
            colorBox.style.backgroundColor = terrain.color;

            const label = document.createElement("span");
            label.textContent = terrain.name;

            tile.appendChild(colorBox);
            tile.appendChild(label);
            terrainList.appendChild(tile);

            tile.addEventListener("click", () => {
                selectedColor = terrain.color;
                document.querySelectorAll(".tile").forEach(t => t.classList.remove("selected"));
                tile.classList.add("selected");
            });
        });

        document.querySelectorAll(".tile").forEach(tile => {
            if (tile.dataset.color === selectedColor) {
                tile.classList.add("selected");
            }
        });

        for (let r = 0; r < rows; r++) {
            for (let q = 0; q < cols; q++) {
                hexMap.push({ q, r, s: -q - r, color: "#BBBBBB" });
            }
        }

        function drawHex(x, y, color = "#BBBBBB") {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 3 * i;
                const xOffset = x + Math.cos(angle) * hexRadius;
                const yOffset = y + Math.sin(angle) * hexRadius;
                ctx.lineTo(xOffset, yOffset);
            }
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = "#333333";
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            hexMap.forEach(hex => {
                const x = hex.q * hexWidth * 0.75 + hexRadius;
                const y = hex.r * hexVerticalSpacing + (hex.q % 2 === 0 ? hexHeight / 2 : 0) + hexHeight / 2;
                drawHex(x, y, hex.color);
            });
        }

        function saveHistory() {
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }

            const currentState = JSON.stringify(hexMap);
            if (history.length === 0 || JSON.stringify(history[historyIndex]) !== currentState) {
                history.push(JSON.parse(currentState));
                historyIndex++;
            }
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                hexMap.length = 0;
                hexMap.push(...JSON.parse(JSON.stringify(history[historyIndex])));
                drawMap();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                hexMap.length = 0;
                hexMap.push(...JSON.parse(JSON.stringify(history[historyIndex])));
                drawMap();
            }
        }

        function getHexAt(x, y) {
            for (const hex of hexMap) {
                const hexX = hex.q * hexWidth * 0.75 + hexRadius;
                const hexY = hex.r * hexVerticalSpacing + (hex.q % 2 === 0 ? hexHeight / 2 : 0) + hexHeight / 2;
                const dx = x - hexX;
                const dy = y - hexY;
                if (Math.sqrt(dx * dx + dy * dy) < hexRadius) {
                    return hex;
                }
            }
            return null;
        }

        // Paint a hex
        function paintHex(hex) {
            if (hex.color === selectedColor) return; // Sprawdzenie, czy kolor już jest taki sam
            saveHistory();  // Save the current state before making a change

            if (selectedTool === "pencil") {
                hex.color = selectedColor;
            } else if (selectedTool === "big-pencil") {
                const neighbors = [
                    { q: hex.q, r: hex.r },
                    { q: hex.q + 1, r: hex.r },
                    { q: hex.q - 1, r: hex.r },
                    { q: hex.q, r: hex.r + 1 },
                    { q: hex.q, r: hex.r - 1 },
                    { q: hex.q + 1, r: hex.r + 1 },
                    { q: hex.q - 1, r: hex.r + 1 }
                ];
                neighbors.forEach(neighbor => {
                    const hexToPaint = hexMap.find(h => h.q === neighbor.q && h.r === neighbor.r);
                    if (hexToPaint && hexToPaint.color !== selectedColor) { // Sprawdzenie koloru sąsiadów
                        hexToPaint.color = selectedColor;
                    }
                });
            } else if (selectedTool === "bucket") {
                if (hex.color === selectedColor) return;
                const targetColor = hex.color;
                const queue = [hex];
                while (queue.length) {
                    const current = queue.pop();
                    if (current.color === targetColor) {
                        current.color = selectedColor;
                        const neighbors = hexMap.filter(h => {
                            const dx = Math.abs(h.q - current.q);
                            const dy = Math.abs(h.r - current.r);
                            return dx <= 1 && dy <= 1;
                        });
                        queue.push(...neighbors.filter(h => h.color === targetColor));
                    }
                }
            }
            drawMap();
        }


        canvas.addEventListener("mousedown", event => {
            isPainting = true;
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const hex = getHexAt(mouseX, mouseY);
            if (hex) paintHex(hex);
        });

        canvas.addEventListener("mousemove", event => {
            if (isPainting) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                const hex = getHexAt(mouseX, mouseY);
                if (hex) paintHex(hex);
            }
        });

        canvas.addEventListener("mouseup", () => { isPainting = false; });
        canvas.addEventListener("mouseleave", () => { isPainting = false; });

        const toolButtons = document.querySelectorAll(".tool-button");
        toolButtons.forEach(button => {
            button.addEventListener("click", () => {
                selectedTool = button.dataset.tool;
                toolButtons.forEach(btn => btn.classList.remove("selected"));
                button.classList.add("selected");
            });
        });

        exportButton.addEventListener("click", () => {
            const dataStr = JSON.stringify(hexMap, null, 2);
            const blob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "hexMap.json";
            a.click();
            URL.revokeObjectURL(url);
        });

        importButton.addEventListener("click", () => {
            fileInput.click();
        });

        fileInput.addEventListener("change", event => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = e => {
                    const json = JSON.parse(e.target.result);
                    hexMap.length = 0;
                    hexMap.push(...json);
                    saveHistory();
                    drawMap();
                };
                reader.readAsText(file);
            }
        });

        // Undo and Redo buttons
        undoButton.addEventListener("click", undo);
        redoButton.addEventListener("click", redo);

        // Obsługa skrótów klawiszowych
        document.addEventListener("keydown", event => {
            if (event.ctrlKey && event.key === "z") {
                // Ctrl + Z: Undo
                event.preventDefault(); // Zapobiegaj domyślnym akcjom (np. cofaniu w polach tekstowych)
                undo();
            }
            if (event.ctrlKey && event.key === "y") {
                // Ctrl + Y: Redo
                event.preventDefault(); // Zapobiegaj domyślnym akcjom
                redo();
            }
        });

        saveHistory();
        drawMap();
    </script>
</body>
</html>
